<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>TinyKV 实现总结 - OneStep</title><meta name=Description content="用尽全力，活成一个普通人"><meta property="og:title" content="TinyKV 实现总结"><meta property="og:description" content="TinyKV是教学项目，算是PingCAP TiKV的go语言简化版，实现了一个带有调度器的基于multi-raft的分布式K/V存储。 项目源"><meta property="og:type" content="article"><meta property="og:url" content="https://waruto.top/posts/tinykv-impl/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-21T00:46:53+08:00"><meta property="article:modified_time" content="2022-05-21T00:46:53+08:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="TinyKV 实现总结"><meta name=twitter:description content="TinyKV是教学项目，算是PingCAP TiKV的go语言简化版，实现了一个带有调度器的基于multi-raft的分布式K/V存储。 项目源"><meta name=application-name content="OneStep"><meta name=apple-mobile-web-app-title content="OneStep"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://waruto.top/posts/tinykv-impl/><link rel=prev href=https://waruto.top/posts/mit-6.830-lab6-rollback-and-recovery/><link rel=next href=https://waruto.top/posts/tinysql-impl/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"TinyKV 实现总结","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/waruto.top\/posts\/tinykv-impl\/"},"genre":"posts","wordcount":6081,"url":"https:\/\/waruto.top\/posts\/tinykv-impl\/","datePublished":"2022-05-21T00:46:53+08:00","dateModified":"2022-05-21T00:46:53+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"waruto210"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=OneStep><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/logo.jpeg data-srcset="/images/logo.jpeg, /images/logo.jpeg 1.5x, /images/logo.jpeg 2x" data-sizes=auto alt=/images/logo.jpeg title=/images/logo.jpeg width=610 height=610>OneStep</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/>首页 </a><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/friendlinks>友链 </a><a class=menu-item href=/about>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=OneStep><img class="lazyload logo" src=/svg/loading.min.svg data-src=/images/logo.jpeg data-srcset="/images/logo.jpeg, /images/logo.jpeg 1.5x, /images/logo.jpeg 2x" data-sizes=auto alt=/images/logo.jpeg title=/images/logo.jpeg width=610 height=610>OneStep</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/ title>首页</a><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/friendlinks title>友链</a><a class=menu-item href=/about title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">TinyKV 实现总结</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/waruto210 title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>waruto210</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-05-21>2022-05-21</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 6081 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 13 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#project1-standalonekv>Project1 StandaloneKV</a></li><li><a href=#project2-raftkv>Project2 RaftKV</a><ul><li><a href=#part-a>Part A</a></li><li><a href=#part-b>Part B</a></li><li><a href=#part-c>Part C</a></li></ul></li><li><a href=#project3-multiraftkv>Project3 MultiRaftKV</a><ul><li><a href=#part-a-1>Part A</a></li><li><a href=#part-b-1>Part B</a><ul><li><a href=#leader-transfer和conf-change>leader transfer和conf change</a></li><li><a href=#split-region-in-raftstore>split region in raftstore</a></li></ul></li><li><a href=#part-c-1>Part C</a></li></ul></li><li><a href=#project-4-transactions>Project 4: Transactions</a><ul><li><a href=#part-a-2>Part A</a></li><li><a href=#part-b-2>Part B</a></li><li><a href=#part-b-3>Part B</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>TinyKV是教学项目，算是PingCAP TiKV的go语言简化版，实现了一个带有调度器的基于multi-raft的分布式K/V存储。</p><p>项目源地址：https://github.com/tidb-incubator/tinykv</p><p>我的实现：https://github.com/waruto210/tinykv</p><h2 id=project1-standalonekv>Project1 StandaloneKV</h2><p>基于PingCAP修改的badger实现一个单机的支持column family的K/V存储。这个非常简单，唯一让我觉得不舒服的就是，文档和注释并没有提示应该某些情况是否应该抛出error，比如KeyNotFound，要查看测试才知道。</p><p>基于badger实现<code>StandAloneStorage</code>，要求实现如下的<code>Storage</code>接口，这个接口也是后面真正的分布式<code>RaftStorage</code>要实现的接口。另外还有一个<code>MemStorage</code>实现了该接口，用于测试。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Storage</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Start</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=nf>Stop</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=nf>Write</span><span class=p>(</span><span class=nx>ctx</span> <span class=o>*</span><span class=nx>kvrpcpb</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>batch</span> <span class=p>[]</span><span class=nx>Modify</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>	<span class=nf>Reader</span><span class=p>(</span><span class=nx>ctx</span> <span class=o>*</span><span class=nx>kvrpcpb</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>StorageReader</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>StorageReader</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// When the key doesn&#39;t exist, return nil for the value
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>GetCF</span><span class=p>(</span><span class=nx>cf</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>key</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>IterCF</span><span class=p>(</span><span class=nx>cf</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>engine_util</span><span class=p>.</span><span class=nx>DBIterator</span>
</span></span><span class=line><span class=cl>	<span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=project2-raftkv>Project2 RaftKV</h2><p>这部分要求实现一个单个region的raft kv。</p><h3 id=part-a>Part A</h3><p>在最内部的<code>Raft</code>结构中，使用<code>RaftLog</code>来管理日志。它维护着各种index：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>snapshot/first.....applied....committed....stabled.....last
</span></span></code></pre></td></tr></table></div></div><p>所有未压缩的log entries都会被放在内存中的<code>entries</code>数组（日志压缩后，应该更新），从<code>first</code>开始；<code>stable</code>表示已经被持久化到<code>storage</code>中的日志，last表示当前最新日志。</p><p>新建Raft时，注意从<code>config.storage</code>回复之前的信息；选举时，要注意处理一些corner case，例如只有一个节点。</p><p>当节点成为Leader后，应该先Append一个no-op entry，并广播给其他节点，因为新Leader虽然一定具有最新的日志，但commit index不一定是最新的，而且Raft不允许Leader直接commit不属于自己任期的日志，这样可以尽快更快地更新Leader的commit index到最新。在PingCAP的<a href=https://pingcap.com/zh/blog/lease-read target=_blank rel="noopener noreffer">TiKV 功能介绍 - Lease Read</a>
中也提到了这个问题，etcd和TiKV刚开始都没注意到这个Bug。</p><p>然后要实现<code>RawNode</code>的两个关键方法:<code>HasReady()</code>和<code>Advance()</code>。前者返回一个<code>Ready</code>结构体，记录了Raft实例的状态，需要被持久化的日志，需要被apply的日志，需要被apply的snapshot，需要发送到其他Raft实例的消息；后者在前者返回的<code>Ready</code>被处理后，需要更新<code>Raft</code>实例的相关状态。</p><h3 id=part-b>Part B</h3><p>这一部分是驱动Raft KV的核心。</p><p>主要步骤为：</p><ol><li>对TinyKV的操作被发送给Raft Leader所在节点；</li><li>Leader节点的<code>peerMsgHandler.proposeRaftCommand</code>记录proposal，并将操作转化为Raft log，驱动Raft达成共识；</li><li><code>peerMsgHandler.HandleRaftReady</code>：每个节点通过<code>RawNode</code>获取<code>Ready</code>，将需要被持久化的信息持久化，将需要被发送的消息发送出去，然后调用<code>Advance</code>，更新Raft实例的状态。</li><li>Leader节点还需要处理当初留下的proposal，通过callback回复客户端。</li></ol><p>对于读操作，可以直接将其转化为一个Log，等到<code>HandleRaftReady</code>时回复客户端，这延迟会很高；也可以采用Raft论文 section8的优化措施，PingCAP的<a href=https://pingcap.com/zh/blog/lease-read target=_blank rel="noopener noreffer">TiKV 功能介绍 - Lease Read</a>
中也做了说明。另外，apply log也可以异步执行，提升效率。</p><h3 id=part-c>Part C</h3><p>参照PingCAP的<a href=https://pingcap.com/zh/blog/tikv-source-code-reading-10 target=_blank rel="noopener noreffer">TiKV 源码解析系列文章（十）Snapshot 的发送和接收</a>
。</p><blockquote><p>在 Raft 中，Snapshot 指的是整个 State Machine 数据的一份快照，大体上有以下这几种情况需要用到 Snapshot：</p><ol><li>正常情况下 leader 与 follower 之间是通过 append log 的方式进行同步的，出于空间和效率的考虑，leader 会定期清理过老的 log。假如 follower/learner 出现宕机或者网络隔离，恢复以后可能所缺的 log 已经在 leader 节点被清理掉了，此时只能通过 Snapshot 的方式进行同步。</li><li>Raft 加入新的节点的，由于新节点没同步过任何日志，只能通过接收 Snapshot 的方式来同步。实际上这也可以认为是 1 的一种特殊情形。</li><li>出于备份/恢复等需求，应用层需要 dump 一份 State Machine 的完整数据。</li></ol></blockquote><p>实际上主要是情况1和2。</p><p>Snapshot不是作为普通的RaftMessage发送的，因为其Size太大。</p><p>Raftstore 想要gc时，propose一个AdminCmdType_CompactLog，等到commit后，处理ready时，修改RaftTruncatedState，然后进行实际的gc删除日志。后续Raft Leader向follower发送日志时，如果找不到next指针对应的log，那么该log由于compaction已经被丢弃了，所以只能发送snapshot。Leader调用<code>Storage.Snapshot()</code>生成snapshot，就绪后，Leader发出snapshot message，follower 收到snapshot message后，follower调用handleSnapshot处理，在<code>RaftLog</code>中记录<code>pendingSnapshot</code>，等<code>handleRaftReady</code>时，根据snapshot message的内信息，新建task去apply snapshot。snapshot具体的传输及apply细节TinyKV框架已经实现好了，要了解的话，可以查看👆的文章。</p><h2 id=project3-multiraftkv>Project3 MultiRaftKV</h2><p>这一点，要实现多region多Raft Group的机制。</p><h3 id=part-a-1>Part A</h3><p>实现3A的leader transfer和conf change非常简单，我觉得这里安排不合理，把太多内容安排到3B了，3A的测试也不足，导致很多坑在3B才被发现。</p><p>Raft实例使用<code>PendingConfIndex</code>来记录最新的conf change entry的index，如果有更新的conf change entry，应该修改为最新的，因为可能有Leader propose新的conf change之后，没有来得及复制到大多数节点，Leader崩溃，重新选举的Leader没有该日志，此时客户端可能会propose新的conf change。</p><h3 id=part-b-1>Part B</h3><h4 id=leader-transfer和conf-change>leader transfer和conf change</h4><p>这部分要实现对<code>AdminCmdType_TransferLeader</code>和<code>AdminCmdType_ChangePeer</code>的处理。</p><p>当<code>Raft.leadTransferee</code>不为None时，为了使leader transfer尽快成功，应该拒绝propose新的command。</p><p>对于conf change，有一些坑。</p><p>首先，新建peer的Raft实例，其<code>Raft.Prs</code>是空的，要等到apply snapshot后，才能获取到当前Group的peers信息，这种情况下，<code>r.Prs[r.id]</code>不存在，而另一种情况，r由于conf change被删除，<code>r.Prs[r.id]</code>也不存在，如果直接返回，依靠判断<code>r.Prs[r.id]</code>来决定是否要处理message，是不行的。所以，作如下的判断，让新peer能够正常接收message。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>Step</span><span class=p>(</span><span class=nx>m</span> <span class=nx>pb</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Your Code Here (2A).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// if r have been removed due to conf change
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// or new added node has no Prs but should step
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Prs</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>Id</span><span class=p>];</span> <span class=p>!</span><span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>Prs</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Infof</span><span class=p>(</span><span class=s>&#34;%d do not exist and have other peers return, term %d, Prs %+v\n&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Id</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Term</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Prs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nx>r</span><span class=p>.</span><span class=nx>State</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>StateFollower</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nf>stepFollower</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>StateCandidate</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nf>stepCandidate</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>StateLeader</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nf>stepLeader</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>此外，考虑到新节点没有数据，为了避免不必要的超时选举（而且由于<code>Prs</code>为空，所以选举会直接成功，造成脑裂），当节点的term为0时，不进行tick；收到Leader的心跳后，立即将自己和Leader加入到<code>r.Prs</code>中。</p><p>解决完以上问题后，跑测试出现超时的概率还是比较大，通过打log发现以下问题：执行完<code>Raft.addNode</code>后，Leader向新peer发送snapshot，但是有时会出现Leader先发送完snapshot后，新的peer才创建完成，开始接受消息，导致这个snapshot就消失了。在我的实现中，Leader发送snapshot后，直接设置自己的<code>r.Prs[to].Next = snapshot.Metadata.Index + 1</code>，因为不这样做，很可能在新peer的response回来之前，又因为触发<code>sendAppend</code>向其发送snapshot，而生成snapshot是极其费时的；但是在前面的问题下，由于snapshot丢了，那么Leader发送后续日志时，新peer会拒绝，Leader将Next -= 1，然后继续，直到Next小于Leader日志的first index，如此来回，耗费了大量时间，自然就超时了。所以，最后在我的实现中，follower会将response message的<code>m.Index</code>设置为自己的last index，leader发现其小于自己的first index的话，就立即发送snapshot，解决snapshot丢失的问题。</p><p>此外，conf change有一个特殊case。考虑：当前Raft group有两个节点Leader A、Follower B，conf change要remove A，那么会出现以下问题，A把conf change的log成功复制给B之后，A apply conf change，把自己删除，没来得及把新的commit index发送给B；此时B的commit index不够新，无法apply这条con change，然后B超时，开启选举，此时B的<code>Prs</code>中还有A，B永远无法选举成功。这种问题有一个解决办法，就是remove自己时，计算quorum不要把自己算进去。但是TinyKV的框架不方便实现这个，底层Raft并不知道是remove还是add，更不知道remove谁，要实现的话，需要更改一些代码。所以我选择，在这种情况下，直接return，不予接受。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=nx>req</span><span class=p>.</span><span class=nx>ChangePeer</span><span class=p>.</span><span class=nx>ChangeType</span> <span class=o>==</span> <span class=nx>eraftpb</span><span class=p>.</span><span class=nx>ConfChangeType_RemoveNode</span> <span class=o>&amp;&amp;</span> <span class=nx>d</span><span class=p>.</span><span class=nf>IsLeader</span><span class=p>()</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>  	<span class=nb>len</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nf>Region</span><span class=p>().</span><span class=nx>Peers</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span> <span class=o>&amp;&amp;</span> <span class=nx>req</span><span class=p>.</span><span class=nx>ChangePeer</span><span class=p>.</span><span class=nx>Peer</span><span class=p>.</span><span class=nx>Id</span> <span class=o>==</span> <span class=nx>d</span><span class=p>.</span><span class=nf>PeerId</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//log.Infof(&#34;%s return corner case\n&#34;, d.Tag)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%s return corner case\n&#34;</span><span class=p>,</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Tag</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>cb</span><span class=p>.</span><span class=nf>Done</span><span class=p>(</span><span class=nf>ErrResp</span><span class=p>(</span><span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>err</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=split-region-in-raftstore>split region in raftstore</h4><p>这里要实现region分裂，实现了这个，就真的实现了multi-raft K/V store了。流程比较简单，按照文档给出的流程就好了。</p><p>不过在测试中遇到了<code>no region</code>问题，在<a href=https://asktug.com/t/topic/274159 target=_blank rel="noopener noreffer">asktug</a>
上，发现这个问题挺普遍的。这是因为：向PD请求region信息时，找不到对应的region信息。</p><p>region分裂一般的实现是 [A, B) -> [A, C) + [C, B)，现有region分配为[A, C)，新region分配为[C, B)。旧region是正常的，Leader在持续给PD发送心跳，PD能够及时更新region信息，而新region还需要等待多个peer创建完成，超时，然后选出Leader，发送心跳给PD。因为，向PD查新region信息时，有一段时间查不到[C, B)的信息。</p><p>我的解决方案是：首先，对于Term为5的节点（region分裂，新建的正常节点Term是5），立即开始选举，为了防止多个节点同时开始选举，导致多次选举失败，可以仅让Id为偶数的节点开始选举；此外，由于测试中，请求的key在增大，所以为了可以让旧region负责[C, B)，新region负责[A, C)，这样能够split完成后，能够立即响应新的请求，不过这种改进感觉只算是为了通过测试的tricky。</p><h3 id=part-c-1>Part C</h3><p>这部分是实现一个小型的PD，实现收集心跳与集群平衡，比较简单，按照文档实现即可。</p><p>不过，文档中少了一个限制条件，在测试中体现了，被迁移的region，其分布的store数量要满足集群的<code>MaxReplicas</code>。这应该是为了防止迁移region导致集群不可用，做的优化。</p><h2 id=project-4-transactions>Project 4: Transactions</h2><p>TinyKV采用的Percolator算法，提供了snapshot隔离性： 快照隔离保证在事务T过程中的所有读取都会看到一个一致的数据库快照（事务看到的所有数据，都是在事务<strong>开始的时间点之前 committed</strong> 的数据），并且只有在T所做的更新与该快照之后的任何并发更新没有冲突时，事务本身才能成功提交。</p><p>Percolator算法源自<a href=https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf target=_blank rel="noopener noreffer">Large-scale Incremental Processing Using Distributed Transactions and Notifications</a>
，可以参考PingCAP这篇文章<a href=https://tikv.org/deep-dive/distributed-transaction/percolator/ target=_blank rel="noopener noreffer">Deep Dive TiKV - Percolator</a>
，还有这个文章<a href=http://mysql.taobao.org/monthly/2018/11/02/ target=_blank rel="noopener noreffer">Google Percolator 分布式事务实现原理解读</a>
。</p><h3 id=part-a-2>Part A</h3><p>这部分就是实现对MVCC基础结构的封装，比较简单，但是代码可能写起来有点烦。</p><h3 id=part-b-2>Part B</h3><p>这部分实现Percolator事务最关键的三个操作，读，Pewwrite，和commit。</p><ul><li><p>KvGet：</p><ul><li>时间戳ts</li><li>查找是否有[0, ts]的锁，如果有，那么我们不能确定该事务是否在ts前被commit（已经commit，锁还没释放完），返回，稍后重试；如果没有，可以读</li><li>从write CF读取[0, ts]范围内最新的write记录，从中获取对应事务的start_ts</li><li>根据start_ts然后读取default CF</li></ul></li><li><p>KvPrewrite</p><ul><li>时间戳start_ts</li><li>对每个key，加一个lock，然后以start_ts把数据写入default CF，选择一个lock为primary lock，每个lock都包括start_ts；如果key上已经有lock，回滚事务</li></ul></li><li><p>Kv Commit</p><ul><li>时间戳commit_ts</li><li>移除primary lock，同时在write CF写入一个时间戳为commit_ts，值为start_ts的记录，表明数据的最新版本是 startTs 对应的数据；如果primary lock没有了（超时，被其他事务移除了），事务失败</li><li>移除所有secondary lock</li></ul><p>只要primary lock被移除，事务就算成功。</p></li></ul><p>有一个比较关键的地方，原Percolator系统基于BigTable，它是支持单行事务的，lock，write，data只不过是单行的一个列；而TinyKV这里，是3个CF，虽然我们可以原子性的写入3个CF，但是考虑：如果两个事务同时检查Key是否加锁，然后发现没有锁，在同时写入锁，这中间并不会有任何阻碍。所以，框架提供了Latch，注释写道:</p><blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Only one thread can hold a latch at a time and all keys that a command might write must be locked
</span></span><span class=line><span class=cl>// at once.
</span></span></code></pre></td></tr></table></div></div></blockquote><h3 id=part-b-3>Part B</h3><p>这部分比较简单，实现四个操作，主要是用于检查事务状态，决定回滚还是提交。</p><ul><li><p><code>KvScan</code>：用于按 Key 顺序扫描，类似KvGet一样实现即可；</p></li><li><p><code>KvCheckTxnStatus</code>：用于检查事务锁的状态；</p></li><li><p><code>KvBatchRollback</code>：用于批量回滚数据；</p></li><li><p><code>KvResolveLock</code>：使用<code>KvCheckTxnStatus</code>检查锁的状态后，再使用<code>KvResolveLock</code>回滚或者提交。</p></li><li><p>思考一个问题，即batch get操作，事务T1要读取A、B，是否会存在T1已经读取了A，在读取B之前，A，B被事务T2修改，导致读到的数据不一致呢？
我的理解是不会。考虑两种情况：</p><ul><li><p>T1的ts的比T2的commit_ts小，那么T2的修改对T1是不可见的；</p></li><li><p>T1的ts的比T2的commit_ts大，那么在T2的commit_ts之前，T2已经完成了prewrite，T1应该看到这个lock，T1直接读取失败；</p></li></ul></li><li><p>另一个问题，事务中的读后写，写入值依赖读入值，与可串行化的不同点</p><p>初始A = 50</p><p>T1: read A , wrie A = A + 10</p><p>T2: write A = 70</p><p>如果是可串行化，那么可能是</p><ul><li>T1 -> T2: A = 70</li><li>T2 -> T1: A = 80</li></ul><p>但是percolator提供的snapshot isolation，可能出现：</p><ul><li>T1 read A， T2 write A， T1 write A， A = 60</li></ul></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-05-21</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/posts/tinykv-impl/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://waruto.top/posts/tinykv-impl/ data-title="TinyKV 实现总结" data-via=Jason210314><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/mit-6.830-lab6-rollback-and-recovery/ class=prev rel=prev title="MIT 6.830 Lab6 Rollback And Recovery"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>MIT 6.830 Lab6 Rollback And Recovery</a>
<a href=/posts/tinysql-impl/ class=next rel=next title="TinySQL 实现总结">TinySQL 实现总结<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.103.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/waruto210 target=_blank>waruto210</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://waruto.disqus.com/embed.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-164518488-1",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-164518488-1" async></script></body></html>