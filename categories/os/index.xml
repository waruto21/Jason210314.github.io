<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>OS - 分类 - OneStep</title><link>https://wmc1999.top/categories/os/</link><description>OS - 分类 - OneStep</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>wmc314@outlook.com (waruto210)</managingEditor><webMaster>wmc314@outlook.com (waruto210)</webMaster><lastBuildDate>Wed, 03 Mar 2021 16:35:52 +0000</lastBuildDate><atom:link href="https://wmc1999.top/categories/os/" rel="self" type="application/rss+xml"/><item><title>6.S081 lab10 mmap</title><link>https://wmc1999.top/posts/6-s081-lab10-mmap/</link><pubDate>Wed, 03 Mar 2021 16:35:52 +0000</pubDate><author>作者</author><guid>https://wmc1999.top/posts/6-s081-lab10-mmap/</guid><description>mmap和munmap系统调用允许 UNIX 程序对其地址空间进行更为细致的控制。它们可用于在进程间共享内存，将文件映射到进程地址空间，并作为用户级p</description></item><item><title>6.S081 lab9 fs</title><link>https://wmc1999.top/posts/6-s081-lab9-fs/</link><pubDate>Tue, 02 Mar 2021 21:03:42 +0000</pubDate><author>作者</author><guid>https://wmc1999.top/posts/6-s081-lab9-fs/</guid><description>Large files 本关需要为xv6添加对大文件的支持。xv6的 inode 默认使用 12 个直接块指针和 1 个间接块指针（指向一个存储着块指针的数据块），所以xv6支持的最</description></item><item><title>6.S081 lab8 lock</title><link>https://wmc1999.top/posts/6-s081-lab8-lock/</link><pubDate>Mon, 01 Mar 2021 20:12:11 +0000</pubDate><author>作者</author><guid>https://wmc1999.top/posts/6-s081-lab8-lock/</guid><description>在本实验室中，将重新设计代码以提高并行性。在多核机器上，并行性差的一个常见症状是高强度的锁竞争。提高并行性通常需要改变数据结构和加锁策略，以</description></item><item><title>6.S081 lab7 thread</title><link>https://wmc1999.top/posts/6-s081-lab7-thread/</link><pubDate>Sun, 28 Feb 2021 15:55:05 +0000</pubDate><author>作者</author><guid>https://wmc1999.top/posts/6-s081-lab7-thread/</guid><description>本实验室将让你熟悉多线程。您将在用户级线程包中实现线程切换；使用多线程来加快程序的速度；并实现一个barrier。 Uthread: switching between threads 实验代码中为我们提</description></item><item><title>6.S081 lab6 cow</title><link>https://wmc1999.top/posts/6-s081-lab6-cow/</link><pubDate>Sat, 27 Feb 2021 14:48:15 +0000</pubDate><author>作者</author><guid>https://wmc1999.top/posts/6-s081-lab6-cow/</guid><description>Copy-on-Write Fork for xv6 这次 lab 只有一关，那就是为xv6实现copy on write。 xv6中的fork()系统调用将父进程的用户内存全部复制到子进程中。如果父进</description></item><item><title>6.S081 lab5 lazy</title><link>https://wmc1999.top/posts/6-s081-lab5-lazy/</link><pubDate>Thu, 25 Feb 2021 21:46:35 +0000</pubDate><author>作者</author><guid>https://wmc1999.top/posts/6-s081-lab5-lazy/</guid><description>Eliminate allocation from sbrk() 这次实验的第一关非常简单，就是从sbrk调用中取消内存分配，为之后的lay allocation做准备。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 uint64</description></item><item><title>6.S081 lab4 traps</title><link>https://wmc1999.top/posts/6-s081-lab4-traps/</link><pubDate>Thu, 25 Feb 2021 00:35:58 +0000</pubDate><author>作者</author><guid>https://wmc1999.top/posts/6-s081-lab4-traps/</guid><description>RISC-V assembly 这是一个简单的RISC-V汇编热身关卡。 我们需要查看user/call.asm来回答一些问题，其主要内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13</description></item><item><title>6.S081 lab3 page tables</title><link>https://wmc1999.top/posts/6-s081-lab3-page-tables/</link><pubDate>Mon, 22 Feb 2021 21:55:37 +0000</pubDate><author>作者</author><guid>https://wmc1999.top/posts/6-s081-lab3-page-tables/</guid><description>环境配置 前两个 lab 比较基础，就不写博客记录了，于是从 lab3 开始。 环境配置参考官网 。如果使用ubuntu20.04的话，环境配置比较简单，只需要从q</description></item></channel></rss>